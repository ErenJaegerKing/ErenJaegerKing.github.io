import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,e as r,o as t}from"./app-CtEqakP3.js";const o={};function n(l,i){return t(),a("div",null,i[0]||(i[0]=[r('<h3 id="spi机制" tabindex="-1"><a class="header-anchor" href="#spi机制"><span>SPI机制？</span></a></h3><p>灵魂三问：</p><ol><li>它的<strong>作用</strong>是什么？解决了什么问题？<strong>优点</strong>是什么？</li><li>如果<strong>手撕</strong>一个SPI应用，需要怎么做？应用场景是什么？</li><li>背后的<strong>设计思想</strong>是什么？我们能得到什么启示？</li></ol><p>设计思想：面向接口 + 配置文件 + 反射技术 即使用约定的配置文件、谁提供jar包，也负责提供配置文件（高内聚低耦合）、 使用ClassLoader的getResource和getResources方法，来读取classpath中的配置文件</p><h4 id="spi是什么" tabindex="-1"><a class="header-anchor" href="#spi是什么"><span>SPI是什么</span></a></h4><p>SPI:全称是<strong>S</strong>ervice <strong>P</strong>rovider <strong>I</strong>nterface 它是从Java6开始引入的，是一种基于ClassLoader来<strong>发现并加载服务</strong>的机制。</p><p>一个标准的SPI由三个组件构成</p><ul><li>Service 公开的接口或抽象类，定义了一个抽象的功能模块</li><li>Service Provider 服务的实现类</li><li>ServiceLoader 是SPI机制的核心组件，负责在运行时发现并加载Service Provider</li></ul><h4 id="java-spi的运行流程" tabindex="-1"><a class="header-anchor" href="#java-spi的运行流程"><span>Java SPI的运行流程</span></a></h4><p>Applicaiton应用程序进行加载后，ServiceLoader就会加载Provider。</p><p>注意事项：</p><ol><li>在第三方JAR包中，可以定义多个Provider。</li><li>Application应用程序不用关注Service的具体实现，只需要和Service的接口进行交互。</li></ol><h4 id="java-spi在jdbc中的应用" tabindex="-1"><a class="header-anchor" href="#java-spi在jdbc中的应用"><span>Java SPI在JDBC中的应用</span></a></h4><p>在java spi出现之前，程序员需要使用Class.forName来加载数据库驱动，比如说引入mysql的jar包后，需要再forName厂商给的com.mysql.jdbc.Driver</p><p>是不是过于麻烦，我们不仅要引入jar包，使用的时候还要根据JDBC的不同换不同forName，所以这时候，我们可以用SPI的思想，将配置文件一并写入JAR中。用Java SPI思想的ClassLoader，它除了可以加载类之外，还提供了方法getResource / getResources，可以根据指定的路径，去读取classpath中对应的文件。所以可以用ClassLoader来读取厂商放在JAR包中的配置文件，但是我们要事先约定好配置文件的路径和格式。</p><p>上面的这套机制，我们就叫SPI吧</p><p>使用JDBC的使用导入JAR就可以了，再也不用class.forName</p><h4 id="java-spi的三大规范要素-以mysql的jdbc为主" tabindex="-1"><a class="header-anchor" href="#java-spi的三大规范要素-以mysql的jdbc为主"><span>Java SPI的三大规范要素（以MYSQL的JDBC为主）</span></a></h4><ul><li>规范的配置文件 <ul><li>文件路径：必须是JAR包中的META-INF/service目录下</li><li>文件名称：Service接口的全限定名</li><li>文件内容：Service Provider的全限定名。有几个就写几个</li></ul></li><li>Service Provider类必须具备无参的默认构造方法（需要通过反射技术实例化它）</li><li>保证能加载到配置文件和Service Provider类： <ul><li>method1：将Service Provider的JAR包放在classpath中（最常用的）</li><li>method2：将JAR包安装到JRE的扩展目录中</li><li>method3：自定义一个ClassLoader</li></ul></li></ul><h4 id="手撕一个spi应用实例" tabindex="-1"><a class="header-anchor" href="#手撕一个spi应用实例"><span>手撕一个SPI应用实例</span></a></h4><p>准备一个api项目为Service功能抽象类</p><p>再由服务供应商去实现这个抽象类，实现为provider类，并且需要配置文件目录META-INF.services，再配置一个service接口全限类名， 文件中的内容是Provider类的全限定名，有几个Provider就写几个</p><p>再准备一个运行的项目，使用ServiceLoader发现并加载服务</p><h4 id="java-spi与springboot自动配置" tabindex="-1"><a class="header-anchor" href="#java-spi与springboot自动配置"><span>Java SPI与SpringBoot自动配置</span></a></h4><p>自动配置，即是Auto-Configuraiton</p><ul><li>基于你引入的依赖JAR包，对SpringBoot应用进行自动配置</li><li>提供了自动配置功能的依赖JAR包，通常被称为starter，例如mybatis-spring-boot-starter</li></ul><p>为什么要有这个注解配置呢？</p><ul><li>SpringBoot项目会默认自动扫描当前项目的package，将其中的配置类注入到IOC容器中</li><li>其他框架，MyBatis、RabbitMQ不支持直接扫描注入，就要用到Auto-Configuraiton</li></ul><p>你会怎么设计Auto-Configuraiton？</p><figure><img src="https://drawingbed-686.pages.dev/myblog/202412192048740.png" alt="Spring的SPI自动配置" tabindex="0" loading="lazy"><figcaption>Spring的SPI自动配置</figcaption></figure><p>springboot自动装配案例：MyBatis？</p><figure><img src="https://drawingbed-686.pages.dev/myblog/202412192052282.png" alt="springboot自动装配案例mybatis" tabindex="0" loading="lazy"><figcaption>springboot自动装配案例mybatis</figcaption></figure><p><strong>springboot自动装配的核心流程</strong>：</p><ul><li><ol><li>SpringBoot应用程序启动</li></ol></li><li><ol start="2"><li>通过SpringFactories机制加载配置文件</li></ol><ul><li>即通过ClassLoader去获取classpath中的配置文件META-INF/spring.factories</li></ul></li><li><ol start="3"><li>筛选出所有自动配置类</li></ol><ul><li>在所有配置文件META-INF/spring.factories中，筛选出以EnableAutoConfiguraiton为key的配置值</li></ul></li><li><ol start="4"><li>将这些类注入到Spring IOC容器中</li></ol></li></ul><h3 id="slf4j原理到实践" tabindex="-1"><a class="header-anchor" href="#slf4j原理到实践"><span>SLF4J原理到实践</span></a></h3><p>两个问题</p><ol><li>什么是门面日志框架？</li><li>它的作用是什么？解决了什么问题？</li></ol><p>如果没有门面日志框架，就会发生以下的问题</p><ul><li>更换日志框架时，java应用程序需要修改代码</li><li>如果多种日志框架共存，将不得不维护多套配置文件</li></ul><p>SLF4J日志框架示意图（下次复习的时候可以去官网查看，到时候我想我的英文水平也到了一定的高度了，哈哈哈）</p><p>SLF4J的实现原理</p><ul><li>在SLF4J1.7.X之前是基于JVM类加载机制与底层日志框架进行绑定</li><li>在SLF4J1.8.X是基于Java SPI机制，与底层日志框架进行绑定（经典Java SPI加载Service Provider的过程）</li></ul><h3 id="springboot自动配置" tabindex="-1"><a class="header-anchor" href="#springboot自动配置"><span>SpringBoot自动配置</span></a></h3><p>SpringBoot的自动配置，英文名是Auto-Configuration</p><ul><li>基于引入的jar包，对springboot应用进行自动配置</li><li>为springboot框架的<strong>开箱即用</strong>提供了基础支撑</li></ul><p>下面的不要弄混了</p><ul><li>自动配置：Auto-Configuration</li><li>自动装配：Autowire</li></ul><p>例子：Redis的自动配置：引入依赖，配置一下，直接使用</p><p>可以去查看一个spring-boot-starter-data-redis中的源码，主要查看配置文件及源码其中的自动配置类之一RedisAutoConfiguration</p><h4 id="springboot的启动流程-简化版" tabindex="-1"><a class="header-anchor" href="#springboot的启动流程-简化版"><span>SpringBoot的启动流程（简化版）</span></a></h4><figure><img src="https://drawingbed-686.pages.dev/myblog/202412200934430.png" alt="springboot启动流程简化版" tabindex="0" loading="lazy"><figcaption>springboot启动流程简化版</figcaption></figure><p>加载并处理所有的配置类processConfigurationClasses</p><figure><img src="https://drawingbed-686.pages.dev/myblog/202412200939694.png" alt="processConfigurationClasses" tabindex="0" loading="lazy"><figcaption>processConfigurationClasses</figcaption></figure><p>parse递归代码</p><figure><img src="https://drawingbed-686.pages.dev/myblog/202412200940015.png" alt="parse递归代码" tabindex="0" loading="lazy"><figcaption>parse递归代码</figcaption></figure><p>遍历得到了一个配置类集合，将配置类本身注册到IOC容器中，处理配置类中的@Bean方法，并将其返回类型注册到IOC容器中，处理通过@Import导入的ImportBeanDefinitionRegister</p><ul><li>@ComponentScan <ul><li>对指定的package进行扫描（默认搜索被@Component修饰的配置类）</li><li>通过basePackages 或 basePackClasses，来指定要进行扫描的package</li><li>如果未指定package，则默认扫描当前 @ComponentScan 所修饰的类所在的package</li></ul></li><li>@Import <ul><li>它的作用是提供了一种显式地从其他地方加载配置类的方式（性能好）x</li><li>支持导入 <ul><li>普通类 x</li><li>接口ImportSelecter的实现类 Y</li><li>接口ImportDefinitonRegister的实现类（利用这个特性我们可以给IOC容器动态地导入多个BeanDefinition）x</li></ul></li></ul></li><li>@Conditional <ul><li>它的作用是只有特定条件满足时，才会向IOC容器中注册指定的组件</li><li>OnBean 容器中存在指定Bean</li><li>OnMissingBean 容器中不存在指定的Bean</li><li>OnClass 当classpath中存在指定的类</li><li>OnMissingClass 当classpath不存在指定的类</li><li>OnProperty 当指定的属性具备指定的值</li><li>OnWebApplication 当应用程序是Web应用</li></ul></li></ul><h4 id="springboot自动配置的原理解析" tabindex="-1"><a class="header-anchor" href="#springboot自动配置的原理解析"><span>SpringBoot自动配置的原理解析</span></a></h4><figure><img src="https://drawingbed-686.pages.dev/myblog/202412200958697.png" alt="SpringBoot自动配置的原理解析" tabindex="0" loading="lazy"><figcaption>SpringBoot自动配置的原理解析</figcaption></figure><p>如何实现类 AutoConfigurationImportSelector？</p><ul><li>SpringFactories机制 <ul><li>Java SPI机制的延伸和扩展</li><li>Spring框架的基础机制，在Spring以及SpringBoot源码中导出可见</li><li>可以基于它来实现SpringBoot的自动装配功能</li></ul></li></ul><p><strong>SpingFactories的核心机制</strong>：从classpath中读取到所有jar包中的配置文件META-IF/spring.factories，然后根据指定的key从配置文件中解析出对应的value值</p><p>Java SPI 与 Spring Factories 的对比</p><figure><img src="https://drawingbed-686.pages.dev/myblog/202412201006864.png" alt="Java SPI 与 Spring Factories 的对比" tabindex="0" loading="lazy"><figcaption>Java SPI 与 Spring Factories 的对比</figcaption></figure><figure><img src="https://drawingbed-686.pages.dev/myblog/202412201013455.png" alt="自动配置的流程" tabindex="0" loading="lazy"><figcaption>自动配置的流程</figcaption></figure><h3 id="自定义starter-正式工作之后就去手动自主实现一个" tabindex="-1"><a class="header-anchor" href="#自定义starter-正式工作之后就去手动自主实现一个"><span>自定义starter（正式工作之后就去手动自主实现一个）</span></a></h3><p>starter是&quot;一站式服务&quot;的JAR包，提供了<strong>自动配置</strong>的功能，开箱即用，提供了<strong>良好的依赖管理</strong>，避免遗漏、版本冲突等问题</p><h3 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h3><p><a href="https://www.bilibili.com/video/BV1RY4y1v7mN?spm_id_from=333.788.videopod.sections&amp;vd_source=834d9d69a86c55d6acbaf9e5dbe37bb2" target="_blank" rel="noopener noreferrer">B站UP主：码场安员外，SPI 自动配置，starter</a></p>',69)]))}const g=e(o,[["render",n],["__file","b_springboot.html.vue"]]),d=JSON.parse('{"path":"/notes/Java/c_spring/b_springboot.html","title":"SpringBoot","lang":"zh-CN","frontmatter":{"icon":"","description":"SPI机制？ 灵魂三问： 它的作用是什么？解决了什么问题？优点是什么？ 如果手撕一个SPI应用，需要怎么做？应用场景是什么？ 背后的设计思想是什么？我们能得到什么启示？ 设计思想：面向接口 + 配置文件 + 反射技术 即使用约定的配置文件、谁提供jar包，也负责提供配置文件（高内聚低耦合）、 使用ClassLoader的getResource和getR...","title":"SpringBoot","date":"2024-12-17T00:00:00.000Z","category":["Spring"],"tag":["SpringBoot"],"order":2,"head":[["meta",{"property":"og:url","content":"https://he9.xin/notes/Java/c_spring/b_springboot.html"}],["meta",{"property":"og:site_name","content":"春风不语即随本心"}],["meta",{"property":"og:title","content":"SpringBoot"}],["meta",{"property":"og:description","content":"SPI机制？ 灵魂三问： 它的作用是什么？解决了什么问题？优点是什么？ 如果手撕一个SPI应用，需要怎么做？应用场景是什么？ 背后的设计思想是什么？我们能得到什么启示？ 设计思想：面向接口 + 配置文件 + 反射技术 即使用约定的配置文件、谁提供jar包，也负责提供配置文件（高内聚低耦合）、 使用ClassLoader的getResource和getR..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://drawingbed-686.pages.dev/myblog/202412192048740.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-26T02:08:12.000Z"}],["meta",{"property":"article:author","content":"ErenJaegerKing"}],["meta",{"property":"article:tag","content":"SpringBoot"}],["meta",{"property":"article:published_time","content":"2024-12-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-26T02:08:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"SpringBoot\\",\\"image\\":[\\"https://drawingbed-686.pages.dev/myblog/202412192048740.png\\",\\"https://drawingbed-686.pages.dev/myblog/202412192052282.png\\",\\"https://drawingbed-686.pages.dev/myblog/202412200934430.png\\",\\"https://drawingbed-686.pages.dev/myblog/202412200939694.png\\",\\"https://drawingbed-686.pages.dev/myblog/202412200940015.png\\",\\"https://drawingbed-686.pages.dev/myblog/202412200958697.png\\",\\"https://drawingbed-686.pages.dev/myblog/202412201006864.png\\",\\"https://drawingbed-686.pages.dev/myblog/202412201013455.png\\"],\\"datePublished\\":\\"2024-12-17T00:00:00.000Z\\",\\"dateModified\\":\\"2024-12-26T02:08:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ErenJaegerKing\\",\\"url\\":\\"https://he9.xin\\",\\"email\\":\\"erenjaegerking@qq.com\\"}]}"]]},"headers":[{"level":3,"title":"SPI机制？","slug":"spi机制","link":"#spi机制","children":[]},{"level":3,"title":"SLF4J原理到实践","slug":"slf4j原理到实践","link":"#slf4j原理到实践","children":[]},{"level":3,"title":"SpringBoot自动配置","slug":"springboot自动配置","link":"#springboot自动配置","children":[]},{"level":3,"title":"自定义starter（正式工作之后就去手动自主实现一个）","slug":"自定义starter-正式工作之后就去手动自主实现一个","link":"#自定义starter-正式工作之后就去手动自主实现一个","children":[]},{"level":3,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1734443730000,"updatedTime":1735178892000,"contributors":[{"name":"erenjaeger","email":"ErenJaegerKing@qq.com","commits":5}]},"readingTime":{"minutes":6.54,"words":1963},"filePathRelative":"notes/Java/c_spring/b_springboot.md","localizedDate":"2024年12月17日","excerpt":"<h3>SPI机制？</h3>\\n<p>灵魂三问：</p>\\n<ol>\\n<li>它的<strong>作用</strong>是什么？解决了什么问题？<strong>优点</strong>是什么？</li>\\n<li>如果<strong>手撕</strong>一个SPI应用，需要怎么做？应用场景是什么？</li>\\n<li>背后的<strong>设计思想</strong>是什么？我们能得到什么启示？</li>\\n</ol>\\n<p>设计思想：面向接口 + 配置文件 + 反射技术 即使用约定的配置文件、谁提供jar包，也负责提供配置文件（高内聚低耦合）、\\n使用ClassLoader的getResource和getResources方法，来读取classpath中的配置文件</p>","autoDesc":true}');export{g as comp,d as data};
