import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,e as i,o}from"./app-AejbbOoN.js";const p={};function r(a,e){return o(),t("div",null,e[0]||(e[0]=[i('<div class="hint-container info"><p class="hint-container-title">相关信息</p><p>为了降低依赖，降低耦合</p></div><h1 id="开闭原则-open-closed-principle-ocp" tabindex="-1"><a class="header-anchor" href="#开闭原则-open-closed-principle-ocp"><span>开闭原则（Open Closed Principle，OCP）</span></a></h1><p><strong>对扩展开放，对修改关闭</strong></p><p>软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。</p><h1 id="里氏代换原则-liskov-substitution-principle-lsp" tabindex="-1"><a class="header-anchor" href="#里氏代换原则-liskov-substitution-principle-lsp"><span>里氏代换原则（Liskov Substitution Principle，LSP）</span></a></h1><p>里氏替换原则通俗来讲就是：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能。</strong></p><p>里氏代换原则：任何基类可以出现的地方，子类一定可以出现。</p><p>换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><h1 id="依赖倒转原则-dependence-inversion-principle-dip" tabindex="-1"><a class="header-anchor" href="#依赖倒转原则-dependence-inversion-principle-dip"><span>依赖倒转原则（Dependence Inversion Principle，DIP）</span></a></h1><p>其核心思想是：<strong>要面向接口编程，不要面向实现编程。</strong>(为了降低客户与实现模块间的耦合)</p><p>就是依赖于抽象，不要依赖于具体</p><p>依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）</p><h1 id="单一职责原则-single-responsibility-principle-srp" tabindex="-1"><a class="header-anchor" href="#单一职责原则-single-responsibility-principle-srp"><span>单一职责原则（Single Responsibility Principle，SRP）</span></a></h1><p>单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）。</p><h1 id="接口隔离原则-interface-segregation-principle-isp" tabindex="-1"><a class="header-anchor" href="#接口隔离原则-interface-segregation-principle-isp"><span>接口隔离原则（Interface Segregation Principle，ISP）</span></a></h1><p>接口隔离原则(Interface  Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p><h1 id="迪米特法则-law-of-demeter-lod" tabindex="-1"><a class="header-anchor" href="#迪米特法则-law-of-demeter-lod"><span>迪米特法则（Law of Demeter，LoD）</span></a></h1><p>其含义是：<strong>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。</strong></p><p>迪米特法则又叫最少知识原则（Least Knowledge Principle，LKP)。</p><p>只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。</p><p>其目的是降低类之间的耦合度，提高模块的相对独立性。</p><h1 id="合成复用原则-composite-reuse-principle-crp" tabindex="-1"><a class="header-anchor" href="#合成复用原则-composite-reuse-principle-crp"><span>合成复用原则（Composite Reuse Principle，CRP）</span></a></h1><p>合成复用原则是指：复用时要尽量使用组合/聚合关系（关联关系），少用继承。</p>',23)]))}const l=n(p,[["render",r],["__file","c_principle.html.vue"]]),d=JSON.parse('{"path":"/notes/designPattern/a_basic/c_principle.html","title":"软件开发原则","lang":"zh-CN","frontmatter":{"icon":"","description":"相关信息 为了降低依赖，降低耦合 开闭原则（Open Closed Principle，OCP） 对扩展开放，对修改关闭 软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。 里氏代换原则（L...","title":"软件开发原则","date":"2024-11-03T00:00:00.000Z","category":["设计模式"],"tag":["软件开发原则"],"order":3,"head":[["meta",{"property":"og:url","content":"https://he9.xin/notes/designPattern/a_basic/c_principle.html"}],["meta",{"property":"og:site_name","content":"春风不语即随本心"}],["meta",{"property":"og:title","content":"软件开发原则"}],["meta",{"property":"og:description","content":"相关信息 为了降低依赖，降低耦合 开闭原则（Open Closed Principle，OCP） 对扩展开放，对修改关闭 软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。 里氏代换原则（L..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-03T13:13:35.000Z"}],["meta",{"property":"article:author","content":"ErenJaegerKing"}],["meta",{"property":"article:tag","content":"软件开发原则"}],["meta",{"property":"article:published_time","content":"2024-11-03T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-03T13:13:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"软件开发原则\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-03T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-03T13:13:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ErenJaegerKing\\",\\"url\\":\\"https://he9.xin\\",\\"email\\":\\"erenjaegerking@qq.com\\"}]}"]]},"headers":[],"git":{"createdTime":1730639615000,"updatedTime":1730639615000,"contributors":[{"name":"LiYaoYu","email":"ErenJaegerKing@qq.com","commits":1}]},"readingTime":{"minutes":2.04,"words":613},"filePathRelative":"notes/designPattern/a_basic/c_principle.md","localizedDate":"2024年11月3日","excerpt":"<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">相关信息</p>\\n<p>为了降低依赖，降低耦合</p>\\n</div>\\n<h1>开闭原则（Open Closed Principle，OCP）</h1>\\n<p><strong>对扩展开放，对修改关闭</strong></p>\\n<p>软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。</p>\\n<h1>里氏代换原则（Liskov Substitution Principle，LSP）</h1>","autoDesc":true}');export{l as comp,d as data};
