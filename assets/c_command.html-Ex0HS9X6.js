import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,e as a,o as i}from"./app-DDugn0gO.js";const r={};function o(p,e){return i(),n("div",null,e[0]||(e[0]=[a('<hr><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>设计模式-行为型模式-命令模式</p></div><hr><h3 id="动机" tabindex="-1"><a class="header-anchor" href="#动机"><span>动机</span></a></h3><p>日常生活中，我们出去吃饭都会遇到下面的场景。顾客把订单交给女招待，女招待拿了订单，放在订单台上说订单来了，快餐厨师根据订单准备餐点</p><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义</span></a></h3><p><strong>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。</strong></p><h3 id="结构" tabindex="-1"><a class="header-anchor" href="#结构"><span>结构</span></a></h3><p>命令模式包含以下主要角色：</p><ul><li><strong>抽象命令类（Command）角色</strong>： 定义命令的接口，声明执行的方法。</li><li><strong>具体命令（Concrete Command）角色</strong>：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。</li><li><strong>实现者/接收者（Receiver）角色</strong>： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</li><li><strong>调用者/请求者（Invoker）角色</strong>： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。</li></ul><h3 id="uml" tabindex="-1"><a class="header-anchor" href="#uml"><span>UML</span></a></h3><figure><img src="https://drawingbed-686.pages.dev/myblog/202411051046348.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="案例实现" tabindex="-1"><a class="header-anchor" href="#案例实现"><span>案例实现</span></a></h3><p>将上面的案例用代码实现，那我们就需要分析命令模式的角色在该案例中由谁来充当。</p><p>服务员： 就是调用者角色，由她来发起命令。</p><p>资深大厨： 就是接收者角色，真正命令执行的对象。</p><p>订单： 命令中包含订单。</p><figure><img src="https://drawingbed-686.pages.dev/myblog/202411051047261.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点"><span>优缺点</span></a></h3><p><strong>优点：</strong></p><ul><li><p><strong>降低系统的耦合度</strong></p><p>命令模式能将调用操作的对象与实现该操作的对象解耦。</p></li><li><p><strong>满足<em>开闭原则</em>，对扩展比较灵活</strong></p><p>增加或删除命令非常方便，采用命令模式增加与删除命令不会影响其他类。</p></li><li><p><strong>可以实现宏命令</strong></p><p>命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</p></li><li><p><strong>方便实现 Undo 和 Redo 操作。</strong></p><p>命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</p></li></ul><p><strong>缺点：</strong></p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类。</li><li><strong>系统结构更加复杂</strong>。</li></ul><h3 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景"><span>适用场景</span></a></h3><ul><li>系统需要将<strong>请求调用者和请求接收者解耦</strong>，使得调用者和接收者不直接交互。</li><li>系统需要在<strong>不同的时间</strong>指定请求、将请求排队和执行请求。</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li></ul><h3 id="jdk源码解析" tabindex="-1"><a class="header-anchor" href="#jdk源码解析"><span>JDK源码解析</span></a></h3><p>Runable是一个典型命令模式，Runnable担当命令的角色，Thread充当的是调用者，start方法就是其执行方法</p><p><strong>抽象命令类（Command）角色</strong>： 定义命令的接口，声明执行的方法。</p><figure><img src="https://drawingbed-686.pages.dev/myblog/202411051110026.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>具体命令（Concrete Command）角色</strong>：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。</p><figure><img src="https://drawingbed-686.pages.dev/myblog/202411051110615.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>实现者/接收者（Receiver）角色</strong>： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</p><figure><img src="https://drawingbed-686.pages.dev/myblog/202411051111347.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>调用者/请求者（Invoker）角色</strong>： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。</p><figure><img src="https://drawingbed-686.pages.dev/myblog/202411051111857.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>测试类</strong></p><figure><img src="https://drawingbed-686.pages.dev/myblog/202411051111110.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',37)]))}const s=t(r,[["render",o],["__file","c_command.html.vue"]]),d=JSON.parse('{"path":"/notes/designPattern/d_behavioral/c_command.html","title":"命令模式","lang":"zh-CN","frontmatter":{"icon":"","description":"相关信息 设计模式-行为型模式-命令模式 动机 日常生活中，我们出去吃饭都会遇到下面的场景。顾客把订单交给女招待，女招待拿了订单，放在订单台上说订单来了，快餐厨师根据订单准备餐点 定义 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。 结构 命令模式...","title":"命令模式","date":"2024-11-05T00:00:00.000Z","category":["设计模式"],"tag":["行为型模式","命令模式"],"order":3,"head":[["meta",{"property":"og:url","content":"https://he9.xin/notes/designPattern/d_behavioral/c_command.html"}],["meta",{"property":"og:site_name","content":"春风不语即随本心"}],["meta",{"property":"og:title","content":"命令模式"}],["meta",{"property":"og:description","content":"相关信息 设计模式-行为型模式-命令模式 动机 日常生活中，我们出去吃饭都会遇到下面的场景。顾客把订单交给女招待，女招待拿了订单，放在订单台上说订单来了，快餐厨师根据订单准备餐点 定义 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。 结构 命令模式..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://drawingbed-686.pages.dev/myblog/202411051046348.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-05T03:12:27.000Z"}],["meta",{"property":"article:author","content":"ErenJaegerKing"}],["meta",{"property":"article:tag","content":"行为型模式"}],["meta",{"property":"article:tag","content":"命令模式"}],["meta",{"property":"article:published_time","content":"2024-11-05T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-05T03:12:27.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"命令模式\\",\\"image\\":[\\"https://drawingbed-686.pages.dev/myblog/202411051046348.png\\",\\"https://drawingbed-686.pages.dev/myblog/202411051047261.png\\",\\"https://drawingbed-686.pages.dev/myblog/202411051110026.png\\",\\"https://drawingbed-686.pages.dev/myblog/202411051110615.png\\",\\"https://drawingbed-686.pages.dev/myblog/202411051111347.png\\",\\"https://drawingbed-686.pages.dev/myblog/202411051111857.png\\",\\"https://drawingbed-686.pages.dev/myblog/202411051111110.png\\"],\\"datePublished\\":\\"2024-11-05T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-05T03:12:27.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ErenJaegerKing\\",\\"url\\":\\"https://he9.xin\\",\\"email\\":\\"erenjaegerking@qq.com\\"}]}"]]},"headers":[{"level":3,"title":"动机","slug":"动机","link":"#动机","children":[]},{"level":3,"title":"定义","slug":"定义","link":"#定义","children":[]},{"level":3,"title":"结构","slug":"结构","link":"#结构","children":[]},{"level":3,"title":"UML","slug":"uml","link":"#uml","children":[]},{"level":3,"title":"案例实现","slug":"案例实现","link":"#案例实现","children":[]},{"level":3,"title":"优缺点","slug":"优缺点","link":"#优缺点","children":[]},{"level":3,"title":"适用场景","slug":"适用场景","link":"#适用场景","children":[]},{"level":3,"title":"JDK源码解析","slug":"jdk源码解析","link":"#jdk源码解析","children":[]}],"git":{"createdTime":1730776347000,"updatedTime":1730776347000,"contributors":[{"name":"LiYaoYu","email":"ErenJaegerKing@qq.com","commits":1}]},"readingTime":{"minutes":3.4,"words":1020},"filePathRelative":"notes/designPattern/d_behavioral/c_command.md","localizedDate":"2024年11月5日","excerpt":"<hr>\\n<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">相关信息</p>\\n<p>设计模式-行为型模式-命令模式</p>\\n</div>\\n<hr>\\n<h3>动机</h3>\\n<p>日常生活中，我们出去吃饭都会遇到下面的场景。顾客把订单交给女招待，女招待拿了订单，放在订单台上说订单来了，快餐厨师根据订单准备餐点</p>\\n<h3>定义</h3>\\n<p><strong>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。</strong></p>","autoDesc":true}');export{s as comp,d as data};
