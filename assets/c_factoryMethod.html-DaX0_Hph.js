import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a,o as r}from"./app-ky9JQILa.js";const i={};function o(l,e){return r(),n("div",null,e[0]||(e[0]=[a('<hr><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>设计模式-创建型模式-工厂方法模式</p></div><hr><h3 id="意图" tabindex="-1"><a class="header-anchor" href="#意图"><span>意图</span></a></h3><p>在父类中提供了一个创建对象的方法，允许子类决定实例化对象的类型</p><h3 id="动机" tabindex="-1"><a class="header-anchor" href="#动机"><span>动机</span></a></h3><p>针对简单工厂模式的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义</span></a></h3><p><strong>工厂方法模式</strong>是一种创建型设计模式，  其在父类中提供一个创建对象的方法，  允许子类决定实例化对象的类型。</p><h3 id="结构" tabindex="-1"><a class="header-anchor" href="#结构"><span>结构</span></a></h3><p>工厂方法模式的主要角色：</p><ul><li><strong>抽象工厂</strong>（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li><li><strong>具体工厂</strong>（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li><strong>抽象产品</strong>（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li><strong>具体产品</strong>（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ul><h3 id="uml" tabindex="-1"><a class="header-anchor" href="#uml"><span>UML</span></a></h3><figure><img src="https://drawingbed-686.pages.dev/myblog/202411122238037.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="案例" tabindex="-1"><a class="header-anchor" href="#案例"><span>案例</span></a></h3><figure><img src="https://drawingbed-686.pages.dev/myblog/202411122239949.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。</p><p>工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</p><h3 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点"><span>优缺点</span></a></h3><p><strong>优点：</strong></p><ul><li><strong>减少耦合</strong> 你可以避免创建者和具体产品之间的紧密耦合。</li><li><strong><em>单一职责原则</em>。</strong> 你可以将产品创建代码放在程序的单一位置，  从而使得代码更容易维护。</li><li><strong><em>开闭原则</em>。</strong> 无需更改现有客户端代码，  你就可以在程序中引入新的产品类型。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>引入更多的子类，代码会复杂</strong> 应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。</li></ul><h3 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景"><span>应用场景</span></a></h3><p><strong>当你在编写代码的过程中，  如果无法预知对象确切类别及其依赖关系时，  可使用工厂方法。</strong></p><p>工厂方法将创建产品的代码与实际使用产品的代码分离，  从而能在不影响其他代码的情况下扩展产品创建部分代码。</p><p>例如，  如果需要向应用中添加一种新产品，  你只需要开发新的创建者子类，  然后重写其工厂方法即可。</p><p><strong>如果你希望用户能扩展你软件库或框架的内部组件，  可使用工厂方法。</strong></p><p>继承可能是扩展软件库或框架默认行为的最简单方法。  但是当你使用子类替代标准组件时，  框架如何辨识出该子类？</p><p>解决方案是将各框架中构造组件的代码集中到单个工厂方法中，  并在继承该组件之外允许任何人对该方法进行重写。</p><p><strong>如果你希望复用现有对象来节省系统资源，  而不是每次都重新创建对象，  可使用工厂方法。</strong></p><p>在处理大型资源密集型对象  （比如数据库连接、  文件系统和网络资源）  时，  你会经常碰到这种资源需求。</p><p>让我们思考复用现有对象的方法：</p><ol><li>首先，  你需要创建存储空间来存放所有已经创建的对象。</li><li>当他人请求一个对象时，  程序将在对象池中搜索可用对象。</li><li>…  然后将其返回给客户端代码。</li><li>如果没有可用对象，  程序则创建一个新对象  （并将其添加到对象池中）。</li></ol><p>这些代码可不少！  而且它们必须位于同一处，  这样才能确保重复代码不会污染程序。</p><p>可能最显而易见，  也是最方便的方式，  就是将这些代码放置在我们试图重用的对象类的构造函数中。  但是从定义上来讲，  构造函数始终返回的是<strong>新对象</strong>，  其无法返回现有实例。</p><p>因此，  你需要有一个既能够创建新对象，  又可以重用现有对象的普通方法。  这听上去和工厂方法非常相像。</p>',37)]))}const c=t(i,[["render",o],["__file","c_factoryMethod.html.vue"]]),g=JSON.parse('{"path":"/notes/designPattern/b_creation/c_factoryMethod.html","title":"工厂方法模式","lang":"zh-CN","frontmatter":{"icon":"","description":"相关信息 设计模式-创建型模式-工厂方法模式 意图 在父类中提供了一个创建对象的方法，允许子类决定实例化对象的类型 动机 针对简单工厂模式的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。 定义 工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。 结构 工厂方法模式的主要角色： 抽象工厂（A...","title":"工厂方法模式","date":"2024-11-14T00:00:00.000Z","category":["设计模式"],"tag":["创建型模式","工厂方法模式"],"order":3,"head":[["meta",{"property":"og:url","content":"https://he9.xin/notes/designPattern/b_creation/c_factoryMethod.html"}],["meta",{"property":"og:site_name","content":"春风不语即随本心"}],["meta",{"property":"og:title","content":"工厂方法模式"}],["meta",{"property":"og:description","content":"相关信息 设计模式-创建型模式-工厂方法模式 意图 在父类中提供了一个创建对象的方法，允许子类决定实例化对象的类型 动机 针对简单工厂模式的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。 定义 工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。 结构 工厂方法模式的主要角色： 抽象工厂（A..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://drawingbed-686.pages.dev/myblog/202411122238037.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-12T14:53:10.000Z"}],["meta",{"property":"article:author","content":"ErenJaegerKing"}],["meta",{"property":"article:tag","content":"创建型模式"}],["meta",{"property":"article:tag","content":"工厂方法模式"}],["meta",{"property":"article:published_time","content":"2024-11-14T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-12T14:53:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"工厂方法模式\\",\\"image\\":[\\"https://drawingbed-686.pages.dev/myblog/202411122238037.png\\",\\"https://drawingbed-686.pages.dev/myblog/202411122239949.png\\"],\\"datePublished\\":\\"2024-11-14T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-12T14:53:10.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ErenJaegerKing\\",\\"url\\":\\"https://he9.xin\\",\\"email\\":\\"erenjaegerking@qq.com\\"}]}"]]},"headers":[{"level":3,"title":"意图","slug":"意图","link":"#意图","children":[]},{"level":3,"title":"动机","slug":"动机","link":"#动机","children":[]},{"level":3,"title":"定义","slug":"定义","link":"#定义","children":[]},{"level":3,"title":"结构","slug":"结构","link":"#结构","children":[]},{"level":3,"title":"UML","slug":"uml","link":"#uml","children":[]},{"level":3,"title":"案例","slug":"案例","link":"#案例","children":[]},{"level":3,"title":"优缺点","slug":"优缺点","link":"#优缺点","children":[]},{"level":3,"title":"应用场景","slug":"应用场景","link":"#应用场景","children":[]}],"git":{"createdTime":1730808096000,"updatedTime":1731423190000,"contributors":[{"name":"LiYaoYu","email":"ErenJaegerKing@qq.com","commits":4}]},"readingTime":{"minutes":3.91,"words":1174},"filePathRelative":"notes/designPattern/b_creation/c_factoryMethod.md","localizedDate":"2024年11月14日","excerpt":"<hr>\\n<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">相关信息</p>\\n<p>设计模式-创建型模式-工厂方法模式</p>\\n</div>\\n<hr>\\n<h3>意图</h3>\\n<p>在父类中提供了一个创建对象的方法，允许子类决定实例化对象的类型</p>\\n<h3>动机</h3>\\n<p>针对简单工厂模式的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p>\\n<h3>定义</h3>\\n<p><strong>工厂方法模式</strong>是一种创建型设计模式，&nbsp; 其在父类中提供一个创建对象的方法，&nbsp; 允许子类决定实例化对象的类型。</p>","autoDesc":true}');export{c as comp,g as data};
