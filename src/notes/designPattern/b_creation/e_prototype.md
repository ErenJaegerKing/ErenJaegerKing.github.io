---
icon: ""
description: ""
title: "原型模式"
date: 2024-11-15
category:
  - 设计模式
tag:
  - 创建型模式
  - 原型模式
order: 5
---

---

:::info
设计模式-创建型模式-原型模式
:::

---

### 意图

使你能够复制已有对象，而无需使代码依赖它们所属的类

### 定义

**用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。**

### **结构**

原型模式包含如下角色：

- **抽象原型类**：规定了具体原型对象必须实现的的 clone() 方法。
- **具体原型类**：实现抽象原型类的 clone() 方法，它是可被复制的对象。
- **访问类**：使用具体原型类中的 clone() 方法来复制新的对象。

### UML

![](https://drawingbed-686.pages.dev/myblog/202411122247322.png)

### **实现**

原型模式的克隆分为浅克隆和深克隆。

> 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。
>
> 深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。

Java 中的 Object 类中提供了 clone()方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了 Cloneable 接口的子实现类就是具体的原型类。

**Realizetype（具体的原型类）：**

```java
public class Realizetype implements Cloneable {

    public Realizetype() {
    }

    @Override
    protected Realizetype clone() throws CloneNotSupportedException {
        return (Realizetype) super.clone();
    }
}
```

### 优缺点

**优点：**

- 你可以克隆对象，  而无需与它们所属的具体类相耦合。
- 你可以克隆预生成原型，  避免反复运行初始化代码。
- 你可以更方便地生成复杂对象。
- 你可以用继承以外的方式来处理复杂对象的不同配置。

**缺点：**
•   克隆包含循环引用的复杂对象可能会非常麻烦。

### 使用场景

- 对象的创建非常复杂，可以使用原型模式快捷的创建对象。
- 性能和安全要求比较高。

### 适用场景

**如果你需要复制一些对象，  同时又希望代码独立于这些对象所属的具体类，  可以使用原型模式。**

这一点考量通常出现在代码需要处理第三方代码通过接口传递过来的对象时。  即使不考虑代码耦合的情况，  你的代码也不能依赖这些对象所属的具体类，  因为你不知道它们的具体信息。

原型模式为客户端代码提供一个通用接口，  客户端代码可通过这一接口与所有实现了克隆的对象进行交互，  它也使得客户端代码与其所克隆的对象具体类独立开来。

**如果子类的区别仅在于其对象的初始化方式，  那么你可以使用该模式来减少子类的数量。  别人创建这些子类的目的可能是为了创建特定类型的对象。**

在原型模式中，  你可以使用一系列预生成的、  各种类型的对象作为原型。

客户端不必根据需求对子类进行实例化，  只需找到合适的原型并对其进行克隆即可。

### **扩展（深克隆）**

进行深克隆需要使用对象流。必须实现 Serializable 接口，否则会抛 NotSerializableException 异常。
