import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,e as n,o as i}from"./app-Cusvpd8u.js";const p={};function r(l,e){return i(),a("div",null,e[0]||(e[0]=[n('<hr><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>设计模式-行为型模式-模板方法模式</p></div><hr><h3 id="动机" tabindex="-1"><a class="header-anchor" href="#动机"><span>动机</span></a></h3><p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p><p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义</span></a></h3><p><strong>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</strong></p><h3 id="结构" tabindex="-1"><a class="header-anchor" href="#结构"><span>结构</span></a></h3><p>模板方法（Template Method）模式包含以下主要角色：</p><ul><li><p><strong>抽象类（Abstract Class）</strong>：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。</p><ul><li>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</li><li>基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种： <ul><li><p>抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。</p></li><li><p>具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</p></li><li><p>钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p><p>一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。</p></li></ul></li></ul></li><li><p><strong>具体子类（Concrete Class）</strong>：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</p></li></ul><h3 id="uml" tabindex="-1"><a class="header-anchor" href="#uml"><span>UML</span></a></h3><figure><img src="https://drawingbed-686.pages.dev/myblog/202411042203178.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="案例实现" tabindex="-1"><a class="header-anchor" href="#案例实现"><span>案例实现</span></a></h3><p>【例】炒菜</p><p>炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。</p><figure><img src="https://drawingbed-686.pages.dev/myblog/202411042203206.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>注意：为防止恶意操作，一般模板方法都加上 final 关键词。</p><h3 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点"><span><strong>优缺点</strong></span></a></h3><p><strong>优点：</strong></p><ul><li><p><strong>提高代码复用性</strong></p><p>将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</p></li><li><p><strong>实现了反向控制,符合“开闭原则”</strong></p><p>通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。</p></li></ul><p><strong>缺点：</strong></p><ul><li><p><strong>系统更庞大，设计更抽象</strong></p><p>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</p></li><li><p><strong>提高了代码阅读难度（反向控制）</strong></p><p>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</p></li></ul><h3 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景"><span>适用场景</span></a></h3><ul><li><p><strong>算法的整体步骤很固定，但其中个别部分易变时</strong></p><p>这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</p></li><li><p><strong>需要通过子类来决定父类算法中某个步骤是否执行</strong></p><p>实现子类对父类的反向控制。</p></li></ul><h3 id="jdk源码解析" tabindex="-1"><a class="header-anchor" href="#jdk源码解析"><span>JDK源码解析</span></a></h3><p>InputStream类就使用了模板方法模式。在InputStream类中定义了多个 <code>read()</code> 方法，如下：</p><figure><img src="https://drawingbed-686.pages.dev/myblog/202411042204278.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://drawingbed-686.pages.dev/myblog/202411042204233.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://drawingbed-686.pages.dev/myblog/202411042204928.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://drawingbed-686.pages.dev/myblog/202411042205661.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从上面代码可以看到，无参的 <code>read()</code> 方法是抽象方法，要求子类必须实现。而 <code>read(byte b[])</code> 方法调用了 <code>read(byte b[], int off, int len)</code> 方法，所以在此处重点看的方法是带三个参数的方法。 总结如下： 在InputStream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取len个字节数据。具体如何读取一个字节数据呢？由子类实现。</p>',32)]))}const s=t(p,[["render",r],["__file","a_template.html.vue"]]),d=JSON.parse('{"path":"/notes/designPattern/d_behavioral/a_template.html","title":"模板方法模式","lang":"zh-CN","frontmatter":{"icon":"","description":"相关信息 设计模式-行为型模式-模板方法模式 动机 在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。 例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和...","title":"模板方法模式","date":"2024-11-04T00:00:00.000Z","category":["设计模式"],"tag":["行为型模式","模板方法模式"],"order":1,"head":[["meta",{"property":"og:url","content":"https://he9.xin/notes/designPattern/d_behavioral/a_template.html"}],["meta",{"property":"og:site_name","content":"春风不语即随本心"}],["meta",{"property":"og:title","content":"模板方法模式"}],["meta",{"property":"og:description","content":"相关信息 设计模式-行为型模式-模板方法模式 动机 在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。 例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://drawingbed-686.pages.dev/myblog/202411042203178.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-04T14:36:41.000Z"}],["meta",{"property":"article:author","content":"ErenJaegerKing"}],["meta",{"property":"article:tag","content":"行为型模式"}],["meta",{"property":"article:tag","content":"模板方法模式"}],["meta",{"property":"article:published_time","content":"2024-11-04T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-04T14:36:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"模板方法模式\\",\\"image\\":[\\"https://drawingbed-686.pages.dev/myblog/202411042203178.png\\",\\"https://drawingbed-686.pages.dev/myblog/202411042203206.png\\",\\"https://drawingbed-686.pages.dev/myblog/202411042204278.png\\",\\"https://drawingbed-686.pages.dev/myblog/202411042204233.png\\",\\"https://drawingbed-686.pages.dev/myblog/202411042204928.png\\",\\"https://drawingbed-686.pages.dev/myblog/202411042205661.png\\"],\\"datePublished\\":\\"2024-11-04T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-04T14:36:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ErenJaegerKing\\",\\"url\\":\\"https://he9.xin\\",\\"email\\":\\"erenjaegerking@qq.com\\"}]}"]]},"headers":[{"level":3,"title":"动机","slug":"动机","link":"#动机","children":[]},{"level":3,"title":"定义","slug":"定义","link":"#定义","children":[]},{"level":3,"title":"结构","slug":"结构","link":"#结构","children":[]},{"level":3,"title":"UML","slug":"uml","link":"#uml","children":[]},{"level":3,"title":"案例实现","slug":"案例实现","link":"#案例实现","children":[]},{"level":3,"title":"优缺点","slug":"优缺点","link":"#优缺点","children":[]},{"level":3,"title":"适用场景","slug":"适用场景","link":"#适用场景","children":[]},{"level":3,"title":"JDK源码解析","slug":"jdk源码解析","link":"#jdk源码解析","children":[]}],"git":{"createdTime":1730726433000,"updatedTime":1730731001000,"contributors":[{"name":"LiYaoYu","email":"ErenJaegerKing@qq.com","commits":2}]},"readingTime":{"minutes":3.95,"words":1184},"filePathRelative":"notes/designPattern/d_behavioral/a_template.md","localizedDate":"2024年11月4日","excerpt":"<hr>\\n<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">相关信息</p>\\n<p>设计模式-行为型模式-模板方法模式</p>\\n</div>\\n<hr>\\n<h3>动机</h3>\\n<p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p>\\n<p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p>","autoDesc":true}');export{s as comp,d as data};
