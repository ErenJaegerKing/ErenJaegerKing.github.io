import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,e as l,o as r}from"./app-B5_fYflW.js";const n={};function a(o,e){return r(),t("div",null,e[0]||(e[0]=[l('<div class="hint-container info"><p class="hint-container-title">相关信息</p><p>设计模式总结</p></div><p>优先：</p><ol><li>单例模式【学习难度：★☆☆☆☆，使用频率：★★★★☆】</li><li>工厂方法模式【学习难度：★★☆☆☆，使用频率：★★★★★】</li><li>迭代器模式【学习难度：★★★☆☆，使用频率：★★★★★】</li><li>策略模式【学习难度：★☆☆☆☆，使用频率：★★★★☆】</li><li>建造者模式【学习难度：★★★★☆，使用频率：★★☆☆☆】</li><li>模板方法模式【学习难度：★★☆☆☆，使用频率：★★★☆☆】</li><li>代理模式【学习难度：★★★☆☆，使用频率：★★★★☆】</li><li>责任链模式【学习难度：★★★☆☆，使用频率：★★☆☆☆】</li><li>抽象工厂模式【学习难度：★★★★☆，使用频率：★★★★★】</li><li>适配器模式【学习难度：★★☆☆☆，使用频率：★★★★☆】</li><li>观察者模式【学习难度：★★★☆☆，使用频率：★★★★★】</li><li>外观模式【学习难度：★☆☆☆☆，使用频率：★★★★★】</li></ol><p>一般：</p><ol><li>桥接模式【学习难度：★★★☆☆，使用频率：★★★☆☆】</li><li>组合模式【学习难度：★★★☆☆，使用频率：★★★★☆】</li><li>装饰器模式【学习难度：★★★☆☆，使用频率：★★★☆☆】</li><li>状态模式【学习难度：★★★☆☆，使用频率：★★★☆☆】</li><li>访问者模式【学习难度：★★★★☆，使用频率：★☆☆☆☆】</li><li>中介者模式【学习难度：★★★☆☆，使用频率：★★☆☆☆】</li><li>命令模式【学习难度：★★★☆☆，使用频率：★★★★☆】</li><li>备忘录模式【学习难度：★★☆☆☆，使用频率：★★☆☆☆】</li></ol><p>低优先：</p><ol><li>原型模式【学习难度：★★★☆☆，使用频率：★★★☆☆】</li><li>享元模式【学习难度：★★★★☆，使用频率：★☆☆☆☆】</li><li>解释器模式【学习难度：★★★★★，使用频率：★☆☆☆☆】</li></ol><ul><li><p>Spring</p><ul><li>工厂模式：通过 BeanFactory 和 ApplicationContext 来创建对象</li><li>单例模式：Spring Bean 默认为单例模式</li><li>策略模式：例如 Resource 的实现类，针对不同的资源文件，实现了不同方式的资源获取策略</li><li>代理模式：Spring 的 AOP 功能用到了 JDK 的动态代理和 CGLIB 字节码生成技术</li><li>模板方法：可以将相同部分的代码放在父类中，而将不同的代码放入不同的子类中，用来解决代码重复的问题。比如 RestTemplate、JmsTemplate、JpaTemplate</li><li>适配器模式：Spring AOP 的增强或通知（Advice）使用到了适配器模式</li><li>观察者模式：Spring 事件驱动模型</li><li>桥接模式：可以根据客户的需求能够动态切换不同的数据源。比如我们的项目需要连接多个数据库，客户在每次访问中根据需要会去访问不同的数据库</li></ul></li><li><p>Spring MVC</p><ul><li>组合模式：WebMvcConfigurerComposite，树枝和树叶都实现了相同的抽象类或接口 WebMvcConfigurer</li><li>责任链模式：DispatcherServlet 依次拦截和处理请求</li><li>适配器模式：HandlerAdapter 处理器适配</li></ul></li><li><p>SpringBoot</p></li><li><p>Netty</p></li><li><p>Dubbo</p></li><li><p>Spring Cloud</p></li><li><p>MyBatis</p><ul><li>Builder + Factory 模式：创建 SqlSession 工厂和 SqlSession</li><li>模板方法模式：BaseExecutor 定义执行器基本流程</li><li>解释器模式：SqlNode 动态解析 SQL</li><li>单例模式：ErrorContext 线程唯一</li><li>装饰器模式：Cache 的实现用组合而非继承实现更灵活地缓存方式结合</li><li>迭代器模式：PropertyTokenizer 利用迭代器模式实现属性解析器</li><li>适配器模式：Log 适配不同的日志框架</li></ul></li><li><p>Tomcat</p></li><li><p>Spring Security</p><ul><li>模板方法模式： AbstractUserDetailsAuthenticationProvider 类的设计。认证的逻辑：retrieveUser 该方法用户从数据源中获取用户对象。 抽象类 additionalAuthenticationChecks 该方法用来做额外的校验（登录凭证的校验），这两个抽象的方法是在 DaoAuthenticationProvider 中实现的 DaoAuthenticationProvider 的实现就是从数据库中加载用户，默认检验登录凭证也都是验证密码。</li><li>责任链模式：spring security 过滤链，通过 HttpSecurity 来动态配置过滤器链中的过滤器，具体的代码在 FilterChainProxy$VirtualFilterChain 中 <a href="https://mp.weixin.qq.com/s/EZsChg5YG0TBadU4q_CAnA" target="_blank" rel="noopener noreferrer">深入理解 FilterChainProxy 源码</a></li><li>策略模式：SecurityContextHolder 中定义登录用户信息存储的方法，四种不同策略</li><li>代理模式：在 Spring Security 中最重要的应用就是 Spring Security 过滤器链接入 Web Filter 的过程，使用了 Spring 提供的 DelegatingFilterProxy</li><li>适配器模式：最为常见的 WebSecurityConfigurerAdapter，该类让两个原本不相关的 WebSecurity 和 HttpSecurity 能够在一起工作。</li><li>建造者模式： Spring Security 中对于建造者模式的使用也是非常多，例如典型的 AuthenticationManagerBuilder，它想要建造的对象是 AuthenticationManager，对应的建造方法则是 build。一般建造者模式中建造者类命名以 builder 结尾，而建造方法命名为 build()。</li><li>观察者模式：在 Spring 框架中，观察者模式用于实现 ApplicationContext 的事件处理功能。Spring 为我们提供了 ApplicationEvent 类和 ApplicationListener 接口来启用事件处理。Spring 应用程序中的任何 Bean 实现 ApplicationListener 接口，都会接收到 ApplicationEvent 作为事件发布者推送的消息。在这里，事件发布者是主题(Subject) 和实现 ApplicationListener 的 Bean 的观察者(Observer)。具体到 Spring Security 中，如登录成功事件发布，session 销毁事件等等，都算是观察者模式。例如 AbstractAuthenticationProcessingFilter#successfulAuthentication 方法</li><li>装饰模式：Spring Security 中对于装饰模式也有许多应用。最典型的就是一个请求在通过过滤器链的时候会不停的变，会不停的调整它的功能，通过装饰模式设计出了请求的许多类，例如：HeaderWriterRequest、FirewalledRequest、StrictHttpFirewall、SaveToSessionRequestWrapper</li></ul></li></ul><p>参考资料如下：</p><p><a href="https://www.bilibili.com/video/BV1Np4y1z7BU?vd_source=834d9d69a86c55d6acbaf9e5dbe37bb2&amp;spm_id_from=333.788.videopod.episodes" target="_blank" rel="noopener noreferrer">黑马程序员设计模式视频</a></p><p><a href="https://blog.csdn.net/lovelion/article/details/17517213" target="_blank" rel="noopener noreferrer">LoveLion 博客</a></p><p><a href="https://refactoringguru.cn/" target="_blank" rel="noopener noreferrer">Rrefactoringguru</a></p><p><a href="https://www.cnblogs.com/chenssy/p/3357683.html" target="_blank" rel="noopener noreferrer">chenssy 博客</a></p><p><a href="http://www.techzhang.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF-by-%E7%A8%8B%E5%BA%8F%E5%91%98%E9%B1%BC%E7%9A%AE/" target="_blank" rel="noopener noreferrer">程序员鱼皮路线</a></p><p><a href="https://blog.csdn.net/u012702547/article/details/107682069" target="_blank" rel="noopener noreferrer">SpringSecurity 设计模式</a></p>',15)]))}const c=i(n,[["render",a],["__file","d_summarization.html.vue"]]),g=JSON.parse('{"path":"/notes/designPattern/a_basic/d_summarization.html","title":"设计模式总结","lang":"zh-CN","frontmatter":{"icon":"","description":"相关信息 设计模式总结 优先： 单例模式【学习难度：★☆☆☆☆，使用频率：★★★★☆】 工厂方法模式【学习难度：★★☆☆☆，使用频率：★★★★★】 迭代器模式【学习难度：★★★☆☆，使用频率：★★★★★】 策略模式【学习难度：★☆☆☆☆，使用频率：★★★★☆】 建造者模式【学习难度：★★★★☆，使用频率：★★☆☆☆】 模板方法模式【学习难度：★★☆☆☆...","title":"设计模式总结","date":"2024-11-10T00:00:00.000Z","category":["设计模式"],"tag":["设计模式总结"],"order":4,"star":true,"cover":"/assets/images/bgImage1.jpg","head":[["meta",{"property":"og:url","content":"https://he9.xin/notes/designPattern/a_basic/d_summarization.html"}],["meta",{"property":"og:site_name","content":"春风不语即随本心"}],["meta",{"property":"og:title","content":"设计模式总结"}],["meta",{"property":"og:description","content":"相关信息 设计模式总结 优先： 单例模式【学习难度：★☆☆☆☆，使用频率：★★★★☆】 工厂方法模式【学习难度：★★☆☆☆，使用频率：★★★★★】 迭代器模式【学习难度：★★★☆☆，使用频率：★★★★★】 策略模式【学习难度：★☆☆☆☆，使用频率：★★★★☆】 建造者模式【学习难度：★★★★☆，使用频率：★★☆☆☆】 模板方法模式【学习难度：★★☆☆☆..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://he9.xin/assets/images/bgImage1.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-10T03:03:13.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://he9.xin/assets/images/bgImage1.jpg"}],["meta",{"name":"twitter:image:alt","content":"设计模式总结"}],["meta",{"property":"article:author","content":"ErenJaegerKing"}],["meta",{"property":"article:tag","content":"设计模式总结"}],["meta",{"property":"article:published_time","content":"2024-11-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-10T03:03:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"设计模式总结\\",\\"image\\":[\\"https://he9.xin/assets/images/bgImage1.jpg\\"],\\"datePublished\\":\\"2024-11-10T00:00:00.000Z\\",\\"dateModified\\":\\"2024-12-10T03:03:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ErenJaegerKing\\",\\"url\\":\\"https://he9.xin\\",\\"email\\":\\"erenjaegerking@qq.com\\"}]}"]]},"headers":[],"git":{"createdTime":1731030398000,"updatedTime":1733799793000,"contributors":[{"name":"erenjaeger","email":"ErenJaegerKing@qq.com","commits":4},{"name":"LiYaoYu","email":"ErenJaegerKing@qq.com","commits":2}]},"readingTime":{"minutes":4.63,"words":1390},"filePathRelative":"notes/designPattern/a_basic/d_summarization.md","localizedDate":"2024年11月10日","excerpt":"<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">相关信息</p>\\n<p>设计模式总结</p>\\n</div>\\n<p>优先：</p>\\n<ol>\\n<li>单例模式【学习难度：★☆☆☆☆，使用频率：★★★★☆】</li>\\n<li>工厂方法模式【学习难度：★★☆☆☆，使用频率：★★★★★】</li>\\n<li>迭代器模式【学习难度：★★★☆☆，使用频率：★★★★★】</li>\\n<li>策略模式【学习难度：★☆☆☆☆，使用频率：★★★★☆】</li>\\n<li>建造者模式【学习难度：★★★★☆，使用频率：★★☆☆☆】</li>\\n<li>模板方法模式【学习难度：★★☆☆☆，使用频率：★★★☆☆】</li>\\n<li>代理模式【学习难度：★★★☆☆，使用频率：★★★★☆】</li>\\n<li>责任链模式【学习难度：★★★☆☆，使用频率：★★☆☆☆】</li>\\n<li>抽象工厂模式【学习难度：★★★★☆，使用频率：★★★★★】</li>\\n<li>适配器模式【学习难度：★★☆☆☆，使用频率：★★★★☆】</li>\\n<li>观察者模式【学习难度：★★★☆☆，使用频率：★★★★★】</li>\\n<li>外观模式【学习难度：★☆☆☆☆，使用频率：★★★★★】</li>\\n</ol>","autoDesc":true}');export{c as comp,g as data};
