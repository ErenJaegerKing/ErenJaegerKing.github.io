import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,e,o as s}from"./app-BYFC8n32.js";const n={};function t(p,l){return s(),a("div",null,l[0]||(l[0]=[e(`<h2 id="mysql基础" tabindex="-1"><a class="header-anchor" href="#mysql基础"><span>MySQL基础</span></a></h2><h3 id="什么是关系型数据库" tabindex="-1"><a class="header-anchor" href="#什么是关系型数据库"><span>什么是关系型数据库？</span></a></h3><p>就是一种建立在关系型模型（表示存储数据之间的联系 一对一、一对多、多对多）上面的数据库。</p><h3 id="什么是sql" tabindex="-1"><a class="header-anchor" href="#什么是sql"><span>什么是SQL?</span></a></h3><p>结构化查询语言，专门用来与数据库打交道的</p><h3 id="什么是mysql" tabindex="-1"><a class="header-anchor" href="#什么是mysql"><span>什么是MySQL?</span></a></h3><p>它是开源免费的关系型数据库，主要用于持久化存储我们系统中的一些数据比如用户信息。</p><h3 id="mysql有什么优点" tabindex="-1"><a class="header-anchor" href="#mysql有什么优点"><span>MySQL有什么优点？</span></a></h3><p>免费开源 成熟稳定，功能完善 支持事务 多种引擎 文档丰富 社区活跃 支持分表分库、读写分离、高可用</p><h2 id="mysql字段类型" tabindex="-1"><a class="header-anchor" href="#mysql字段类型"><span>MySQL字段类型</span></a></h2><p>三大类：</p><p>数值型：</p><ul><li>整型：tinyint smallint mediumint int bigint</li><li>浮点型：float double</li><li>定点型：decimal</li></ul><p>字符串类型：</p><ul><li>常用：CHAR VARCHAR</li><li>TEXT类：tinytext text mediumtext longtext</li><li>BLOB类：tinyblob blob mediumblob longblob</li></ul><p>日期时间类型：</p><ul><li>常用：year time date datetime timestamp</li></ul><h3 id="整数类型的unsigned属性有什么用" tabindex="-1"><a class="header-anchor" href="#整数类型的unsigned属性有什么用"><span>整数类型的unsigned属性有什么用？</span></a></h3><p>tinyint unsigned 取值范围是0~255</p><p>int unsigned 取值范围0~4294967295</p><p>整数类型可以使用可选的unsigned属性来表示不允许负值的无符号整数。使用unsigned属性可以将正整数的上限提升一倍</p><h3 id="char-varchar-的区别" tabindex="-1"><a class="header-anchor" href="#char-varchar-的区别"><span>CHAR VARCHAR 的区别</span></a></h3><p>定长字符串 用空格填充以达到指定的长度 eg：身份证 性别</p><p>变长字符串 eg：用户昵称、文章标题</p><h3 id="varchar-100-varchar-10-的区别" tabindex="-1"><a class="header-anchor" href="#varchar-100-varchar-10-的区别"><span>VARCHAR(100) VARCHAR(10) 的区别</span></a></h3><p>100 表示能存储100个字符</p><p>相同字符串的话，占用的磁盘存储空间是一样的</p><p>但是100会消耗更多的内存。因为varchar在排序的时候，在内存上面会占用100个长度的内存</p><h3 id="decimal-和-float-double-的区别是什么" tabindex="-1"><a class="header-anchor" href="#decimal-和-float-double-的区别是什么"><span>decimal 和 float double 的区别是什么</span></a></h3><p>decimal 是 定点数 存储精确的小数值</p><p>float / double 是浮点数 存储近似的小数值</p><p>eg：decimal存储具有精确要求的小数，例如与货币相关的数据，可以避免浮点数带来的精度损失</p><p>在java中，mysql中的decimal类型对应的是java中的java.math.BigDecimal</p><h3 id="mysql索引失效的场景" tabindex="-1"><a class="header-anchor" href="#mysql索引失效的场景"><span>MYSQL索引失效的场景</span></a></h3><ol><li>不遵守最左匹配原则，就是在一个联合索引中 abc，如果没有a 那么就会索引失效</li><li>in not in 如果查询的范围超过数据30%，就会范围过大，造成索引失效</li><li>在条件中，使用了函数计算和表达式计算，就会造成索引值不匹配，就会索引失效</li><li>like % 进行匹配的时候 %在左边就会因为范围过大，造成索引失效</li><li>使用or表达式 左右两边都必须是索引，如果有一边不是索引，就会造成索引失效</li><li>order by 排序的时候，这是mysql自身优化的问题，就是会进行回表，mysql就会认为全表查询会更优，就会造成索引失效</li></ol><h3 id="为什么不推荐使用text和blob" tabindex="-1"><a class="header-anchor" href="#为什么不推荐使用text和blob"><span>为什么不推荐使用Text和Blob？</span></a></h3><p>不推荐</p><h3 id="datetime-和-timestamp-的区别是什么" tabindex="-1"><a class="header-anchor" href="#datetime-和-timestamp-的区别是什么"><span>DATETIME 和 TIMESTAMP 的区别是什么？</span></a></h3><p>datatime 没有时区信息 timestamp 和时区相关</p><p>datatime需要耗费8个字节的存储空间 timestamp只需要使用4个字节的存储空间</p><p>DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</p><p>Timestamp：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</p><h3 id="null和-的区别是什么-为什么-mysql-不建议使用-null-作为列默认值" tabindex="-1"><a class="header-anchor" href="#null和-的区别是什么-为什么-mysql-不建议使用-null-作为列默认值"><span>NULL和&#39;&#39;的区别是什么？为什么 MySQL 不建议使用 NULL 作为列默认值？</span></a></h3><p>&#39;&#39;不占用空间，null是需要占用空间的</p><p>null代表一个不确定的值。两个null不一定相等。例如select null = null结果为false，但是我们使用distinct group by order by时，null又被认为是相等的</p><p>null会影响到聚合函数的结果。sum avg min max会忽略null值</p><p>查询null值，必须使用is null或者is not null，而不能使用= ！= &gt; &lt;之类的运算符，而&#39;&#39;是可以使用这些比较运算符的</p><h3 id="boolean类型如何表示" tabindex="-1"><a class="header-anchor" href="#boolean类型如何表示"><span>Boolean类型如何表示？</span></a></h3><p>mysql并没有专门的布尔类型，而是用tinyint(1)类型来表示布尔值。</p><p>tinyint(1)类型可以存储0或1，分别对应false或true</p><h2 id="mysql基础架构" tabindex="-1"><a class="header-anchor" href="#mysql基础架构"><span>MySQL基础架构</span></a></h2><p>以后来收你，先等着</p><h3 id="mysql支持哪些存储引擎-默认使用哪个" tabindex="-1"><a class="header-anchor" href="#mysql支持哪些存储引擎-默认使用哪个"><span>MySQL支持哪些存储引擎？默认使用哪个？</span></a></h3><p>MyISAM InnoDB 5.5.5 之前是使用前者作为默认引擎的，5.5.5 之后是使用后者作为默认引擎的</p><p>使用select version()来查看你的MySQL版本</p><p>使用show variables like &#39;%storage_engine%&#39;命令直接查看MySQL当前默认的存储引擎</p><h3 id="mysql-存储引擎架构了解吗" tabindex="-1"><a class="header-anchor" href="#mysql-存储引擎架构了解吗"><span>MySQL 存储引擎架构了解吗？</span></a></h3><p>以后来收你，先等着</p><h3 id="myisam-和-innodb-有什么区别" tabindex="-1"><a class="header-anchor" href="#myisam-和-innodb-有什么区别"><span>MyISAM 和 InnoDB 有什么区别？</span></a></h3><p>MyISAM 性能特别好 最大的缺陷是崩溃之后无法安全恢复</p><p>InnoDB 支持事务 行级锁</p><ol><li>是否支持行级锁 m 只有表级 i 有行和表级</li><li>是否支持事务</li></ol><p>i支持事务 实现了SQL定义的四个隔离标准 具有提交commit和回滚rollback事务的能力</p><p>innodb默认是使用的repeatable-read可重读隔离级别是可以解决幻读问题发生的（基于MVCC和Next-Key Lock）</p><ol start="3"><li>是否支持外键</li></ol><p>m不支持 i支持</p><p>阿里开发手册禁止使用外键，一切外键概念必须在应用层解决。因为它不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库插入速度；</p><ol start="4"><li>是否支持数据库异常崩溃后的安全恢复</li></ol><p>m不支持 i支持</p><p>i崩溃后，重新启动的时候保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于redo log</p><ol start="5"><li>是否支持MVCC</li></ol><p>不了解</p><ol start="6"><li>索引实现不一样</li></ol><p>都是用B+树作为索引结构的</p><p>非叶子节点存放的是索引，叶子节点放的是索引+数据</p><ol start="7"><li>性能有差别</li></ol><p>i性能比m更强大</p><ol start="8"><li>数据缓存策略和机制实现不同</li></ol><p>不了解</p><h3 id="myisam-和-innodb-如何选择" tabindex="-1"><a class="header-anchor" href="#myisam-和-innodb-如何选择"><span>MyISAM 和 InnoDB 如何选择？</span></a></h3><p>innodb 在学习高性能的时候，看到一张图片就是i性能是远远超过m的</p><p>而且innodb有这些特别好的特性，有什么理由不选择它呢</p><h2 id="mysql索引" tabindex="-1"><a class="header-anchor" href="#mysql索引"><span>MYSQL索引</span></a></h2><p>重点</p><h2 id="mysql查询缓存" tabindex="-1"><a class="header-anchor" href="#mysql查询缓存"><span>MYSQL查询缓存</span></a></h2><p>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</p><p>MySQL 5.6 开始，查询缓存已默认禁用。MySQL 8.0 开始，已经不再支持查询缓存了</p><h2 id="mysql日志" tabindex="-1"><a class="header-anchor" href="#mysql日志"><span>MYSQL日志</span></a></h2><p>重点</p><h2 id="mysql事务" tabindex="-1"><a class="header-anchor" href="#mysql事务"><span>MYSQL事务</span></a></h2><p>何为事务，就是一组事情要全部执行，要么都不执行</p><h3 id="何为数据库事务" tabindex="-1"><a class="header-anchor" href="#何为数据库事务"><span>何为数据库事务？</span></a></h3><p>数据库事务有什么用呢？要么全部执行成功，要么全部不执行</p><p>关系型数据库事务都有ACID特性：</p><ul><li>A atomicity 原子性 - 要么全部执行，要么全部不执行</li><li>C consistency 一致性 - 执行事务前后，数据保证发生前后一致</li><li>I isolation 隔离性 - 并发访问时，一个事务不会被其他事务所打扰</li><li>D durability 持久性 - 一个事务被提交后，它对数据库中的数据改变是持久的</li></ul><p>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</p><h3 id="并发事务带来了哪些问题" tabindex="-1"><a class="header-anchor" href="#并发事务带来了哪些问题"><span>并发事务带来了哪些问题?</span></a></h3><h4 id="脏读-dirty-read" tabindex="-1"><a class="header-anchor" href="#脏读-dirty-read"><span>脏读（Dirty read）</span></a></h4><p>第一个事务读取数据并对数据进行了修改，但是这个修改对其他事务来说是<strong>可见</strong>的。</p><p>此时第二个事务读取了这个<strong>还未提交</strong>的数据，但是第一个事务突然<strong>回滚</strong>。</p><p>此时第二个事务读取的数据就是脏数据。</p><h4 id="丢失修改-lost-to-modify" tabindex="-1"><a class="header-anchor" href="#丢失修改-lost-to-modify"><span>丢失修改（Lost to modify）</span></a></h4><p>第一个事务读取数据，第二个事务也读取了数据，然后第一个事务修改了数据，第二事务也修改了数据。</p><p>然后事务都进行了提交，那么第一次的修改就会被第二次的修改所<strong>覆盖</strong>，此时就发生了丢失修改。</p><h4 id="不可重复读-unrepeatable-read" tabindex="-1"><a class="header-anchor" href="#不可重复读-unrepeatable-read"><span>不可重复读（Unrepeatable read）</span></a></h4><p>一个事务多次读取同一个数据。</p><p>一个事务访问该数据获取到了数据，然后另一个事务也访问该数据并对这个数据进行修改，此时第一个事务又读取了一次这个数据，结果就发生了两次读取不一样的情况，就发生了不可重复读。</p><h4 id="幻读-phantom-read" tabindex="-1"><a class="header-anchor" href="#幻读-phantom-read"><span>幻读（Phantom read）</span></a></h4><p>与不可重复读类似。</p><p>一个事务读取了多行的数据，接着另一个事务插入了一些数据，然后第一个事务又一次读取了这个数据，事务读取这个范围的数据发现相比与第一次读取的结果多了新的数据</p><h3 id="不可重复读和幻读有什么区别" tabindex="-1"><a class="header-anchor" href="#不可重复读和幻读有什么区别"><span>不可重复读和幻读有什么区别？</span></a></h3><ul><li>不可重复读 内容修改或者记录减少，发现查到的某些记录值被修改了</li><li>幻读 记录新增 多次执行同一条查询语句,发现查到的记录增多了</li></ul><h3 id="并发事务的控制方式有哪些" tabindex="-1"><a class="header-anchor" href="#并发事务的控制方式有哪些"><span>并发事务的控制方式有哪些？</span></a></h3><p>锁 + MVCC 重点 以后来了解</p><h3 id="sql标准定义了哪些事务隔离级别" tabindex="-1"><a class="header-anchor" href="#sql标准定义了哪些事务隔离级别"><span>SQL标准定义了哪些事务隔离级别？</span></a></h3><ul><li>read-uncommitted 读取未提交 允许读取尚未提交的数据变更 脏读 不可重复读 幻读 最低的隔离级别</li><li>read-committed 读取已提交 允许读取并发事务已经提交的数据 不可重复读 幻读</li><li>repeatable-read 可重复读 对同一字段的多次读取结果都是一致的 幻读</li><li>serializable 可串行化 最高的隔离级别，完全服从 ACID 的隔离级别</li></ul><h3 id="mysql-的隔离级别是基于锁实现的吗" tabindex="-1"><a class="header-anchor" href="#mysql-的隔离级别是基于锁实现的吗"><span>MySQL 的隔离级别是基于锁实现的吗？</span></a></h3><p>是基于锁和MVCC机制共同实现的</p><h3 id="mysql-的默认隔离级别是什么" tabindex="-1"><a class="header-anchor" href="#mysql-的默认隔离级别是什么"><span>MySQL 的默认隔离级别是什么?</span></a></h3><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）</p><h2 id="mysql锁" tabindex="-1"><a class="header-anchor" href="#mysql锁"><span>MYSQL锁</span></a></h2><p>重点</p><h2 id="mysql性能优化" tabindex="-1"><a class="header-anchor" href="#mysql性能优化"><span>MYSQL性能优化</span></a></h2><h3 id="能用-mysql-直接存储文件-比如图片-吗" tabindex="-1"><a class="header-anchor" href="#能用-mysql-直接存储文件-比如图片-吗"><span>能用 MySQL 直接存储文件（比如图片）吗？</span></a></h3><p>不要在数据库中存储文件，会严重影响数据库性能，消耗过多的存储空间</p><p>数据库只存储文件地址信息，文件由文件存储服务负责存储。</p><p>优先选择存储文件路径或 URL 的方式，以提高性能和可维护性。</p><h3 id="mysql-如何存储-ip-地址" tabindex="-1"><a class="header-anchor" href="#mysql-如何存储-ip-地址"><span>MySQL 如何存储 IP 地址？</span></a></h3><ul><li>inet_aton：将ip转为无符号整型（4-8位）</li><li>inet_ntoa：将整型的ip转为地址</li></ul><p>插入数据前，先用inet_aton把ip地址转为整型，显示数据时，使用inet_ntoa将整型的ip转换未地址显示就行</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> example</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> AUTO_INCREMENT </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">PRIMARY KEY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ip_address </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> UNSIGNED</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 插入数据</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INSERT INTO</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> example (ip_address) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">VALUES</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (INET_ATON(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;192.168.1.1&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 查询数据</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id, INET_NTOA(ip_address) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">AS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ip_address </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> example;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="有哪些常见的-sql-优化手段" tabindex="-1"><a class="header-anchor" href="#有哪些常见的-sql-优化手段"><span>有哪些常见的 SQL 优化手段？</span></a></h3><h4 id="使用explain进行分析" tabindex="-1"><a class="header-anchor" href="#使用explain进行分析"><span>使用Explain进行分析</span></a></h4><p>使用explain来分析select查询语句，我们开发人员就是可以用select结果来优化查询语句</p><ul><li>select_type：查询类型，有简单查询、联合查询、子查询等</li><li>key：使用的索引</li><li>rows：扫描的行数</li></ul><h4 id="sql优化" tabindex="-1"><a class="header-anchor" href="#sql优化"><span>SQL优化</span></a></h4><ol><li>避免使用Select *</li></ol><ul><li>增加查询解析器的成本</li><li>不走覆盖索引会产生大量的回表查询</li><li>查询不需要的字段会浪费CPU、内存资源</li></ul><ol start="2"><li>小表驱动大表</li></ol><p>学生表 20条数据 ， 分数表 80w条数据</p><p>left join 小表驱动大表</p><ol start="3"><li><p>用连接查询代替子查询</p></li><li><p>提升group by的效率</p></li></ol><ul><li>对进行排序的字段添加索引</li></ul><ol start="5"><li>批量操作</li></ol><ul><li>1w+数据进行批量插入</li></ul><ol start="6"><li>使用Limit</li></ol><ul><li>提高查询效率</li><li>避免过度提取数据</li><li>优化分页查询</li><li>简化查询效果</li></ul><ol start="7"><li>使用union all代替union</li></ol><ul><li>union all 获取所有数据但是数据不去重，包含重复数据</li><li>union 获取所有数据且数据去重，不包含重复数据 union去重会消耗性能和资源</li></ul><ol start="8"><li>join的表不宜过多</li></ol><ul><li>查询效率会下降</li><li>系统负载增加</li><li>维护难度加大</li></ul><h4 id="sql遵循的原则" tabindex="-1"><a class="header-anchor" href="#sql遵循的原则"><span>SQL遵循的原则</span></a></h4><ol><li>减少数据扫描</li><li>返回更少数据</li><li>减少交互次数</li><li>减少服务器CPU及内存开销</li></ol><h3 id="如何分析-sql-的性能" tabindex="-1"><a class="header-anchor" href="#如何分析-sql-的性能"><span>如何分析 SQL 的性能？</span></a></h3><p>使用explain命令来分析SQL的执行计划</p><p>执行计划就是指一条SQL语句经过mysql查询优化器优化后，具体的执行方式</p><p>type：表的访问方法</p><ul><li>system</li><li>const：表中最多只有一行匹配的记录，一次查询就可以找到</li><li>eq_ref：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。</li><li>ref：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。</li><li>index_merge：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。</li><li>range：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。</li><li>index：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。</li><li>ALL：全表扫描</li></ul><p>key：实际用到的索引</p><ul><li>key 列表示 MySQL 实际使用到的索引。如果为 NULL，则表示未用到索引。</li></ul><p>extra：这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。</p><ul><li>Using filesort：在排序时使用了外部的索引排序，没有用到表内索引进行排序。</li><li>Using temporary：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。</li><li>Using index：表明查询使用了覆盖索引，不用回表，查询效率非常高。</li><li>Using index condition:表示查询优化器选择使用了索引条件下推这个特性。</li><li>Using where:表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。</li><li>Using join buffer (Block Nested Loop):连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。</li></ul><p>这是explain命令分析性能最重要的三个参数</p><h3 id="读写分离和分库分表了解吗" tabindex="-1"><a class="header-anchor" href="#读写分离和分库分表了解吗"><span>读写分离和分库分表了解吗？</span></a></h3><p>重点</p><h3 id="深度分页如何优化" tabindex="-1"><a class="header-anchor" href="#深度分页如何优化"><span>深度分页如何优化？</span></a></h3><p>重点</p><h3 id="数据冷热分离如何做" tabindex="-1"><a class="header-anchor" href="#数据冷热分离如何做"><span>数据冷热分离如何做？</span></a></h3><p>重点</p><h3 id="mysql-性能怎么优化" tabindex="-1"><a class="header-anchor" href="#mysql-性能怎么优化"><span>MySQL 性能怎么优化？</span></a></h3><p>点 - 线 - 面</p><p>现阶段最重要的是前两个去实践一下</p><ol><li>慢SQL定位与分析</li></ol><ul><li>监控工具：mysql慢查询日志</li><li>explain命令</li></ul><ol start="2"><li>由点及面：索引、表结构和SQL优化</li></ol><ul><li>索引优化</li><li>表结构优化</li><li>SQL 优化</li></ul><ol start="3"><li>进阶方案：架构优化</li></ol><ul><li>读写分离</li><li>分库分表</li><li>数据冷热分离</li><li>缓存机制</li></ul><ol start="4"><li>其他优化手段</li></ol><ul><li>连接池配置</li><li>硬件配置</li></ul>`,180)]))}const d=i(n,[["render",t],["__file","mysql-javaguide.html.vue"]]),o=JSON.parse(`{"path":"/notes/database/a_mysql/mysql-javaguide.html","title":"MySQL-javaguide","lang":"zh-CN","frontmatter":{"icon":"","description":"MySQL基础 什么是关系型数据库？ 就是一种建立在关系型模型（表示存储数据之间的联系 一对一、一对多、多对多）上面的数据库。 什么是SQL? 结构化查询语言，专门用来与数据库打交道的 什么是MySQL? 它是开源免费的关系型数据库，主要用于持久化存储我们系统中的一些数据比如用户信息。 MySQL有什么优点？ 免费开源 成熟稳定，功能完善 支持事务 多...","title":"MySQL-javaguide","date":"2025-03-11T00:00:00.000Z","category":["数据库"],"tag":["MySQL"],"head":[["meta",{"property":"og:url","content":"https://he9.xin/notes/database/a_mysql/mysql-javaguide.html"}],["meta",{"property":"og:site_name","content":"春风不语即随本心"}],["meta",{"property":"og:title","content":"MySQL-javaguide"}],["meta",{"property":"og:description","content":"MySQL基础 什么是关系型数据库？ 就是一种建立在关系型模型（表示存储数据之间的联系 一对一、一对多、多对多）上面的数据库。 什么是SQL? 结构化查询语言，专门用来与数据库打交道的 什么是MySQL? 它是开源免费的关系型数据库，主要用于持久化存储我们系统中的一些数据比如用户信息。 MySQL有什么优点？ 免费开源 成熟稳定，功能完善 支持事务 多..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-23T09:17:42.000Z"}],["meta",{"property":"article:author","content":"ErenJaegerKing"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:published_time","content":"2025-03-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-23T09:17:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL-javaguide\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-03-11T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-23T09:17:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ErenJaegerKing\\",\\"url\\":\\"https://he9.xin\\",\\"email\\":\\"erenjaegerking@qq.com\\"}]}"]]},"headers":[{"level":2,"title":"MySQL基础","slug":"mysql基础","link":"#mysql基础","children":[{"level":3,"title":"什么是关系型数据库？","slug":"什么是关系型数据库","link":"#什么是关系型数据库","children":[]},{"level":3,"title":"什么是SQL?","slug":"什么是sql","link":"#什么是sql","children":[]},{"level":3,"title":"什么是MySQL?","slug":"什么是mysql","link":"#什么是mysql","children":[]},{"level":3,"title":"MySQL有什么优点？","slug":"mysql有什么优点","link":"#mysql有什么优点","children":[]}]},{"level":2,"title":"MySQL字段类型","slug":"mysql字段类型","link":"#mysql字段类型","children":[{"level":3,"title":"整数类型的unsigned属性有什么用？","slug":"整数类型的unsigned属性有什么用","link":"#整数类型的unsigned属性有什么用","children":[]},{"level":3,"title":"CHAR VARCHAR 的区别","slug":"char-varchar-的区别","link":"#char-varchar-的区别","children":[]},{"level":3,"title":"VARCHAR(100) VARCHAR(10) 的区别","slug":"varchar-100-varchar-10-的区别","link":"#varchar-100-varchar-10-的区别","children":[]},{"level":3,"title":"decimal 和 float double 的区别是什么","slug":"decimal-和-float-double-的区别是什么","link":"#decimal-和-float-double-的区别是什么","children":[]},{"level":3,"title":"MYSQL索引失效的场景","slug":"mysql索引失效的场景","link":"#mysql索引失效的场景","children":[]},{"level":3,"title":"为什么不推荐使用Text和Blob？","slug":"为什么不推荐使用text和blob","link":"#为什么不推荐使用text和blob","children":[]},{"level":3,"title":"DATETIME 和 TIMESTAMP 的区别是什么？","slug":"datetime-和-timestamp-的区别是什么","link":"#datetime-和-timestamp-的区别是什么","children":[]},{"level":3,"title":"NULL和''的区别是什么？为什么 MySQL 不建议使用 NULL 作为列默认值？","slug":"null和-的区别是什么-为什么-mysql-不建议使用-null-作为列默认值","link":"#null和-的区别是什么-为什么-mysql-不建议使用-null-作为列默认值","children":[]},{"level":3,"title":"Boolean类型如何表示？","slug":"boolean类型如何表示","link":"#boolean类型如何表示","children":[]}]},{"level":2,"title":"MySQL基础架构","slug":"mysql基础架构","link":"#mysql基础架构","children":[{"level":3,"title":"MySQL支持哪些存储引擎？默认使用哪个？","slug":"mysql支持哪些存储引擎-默认使用哪个","link":"#mysql支持哪些存储引擎-默认使用哪个","children":[]},{"level":3,"title":"MySQL 存储引擎架构了解吗？","slug":"mysql-存储引擎架构了解吗","link":"#mysql-存储引擎架构了解吗","children":[]},{"level":3,"title":"MyISAM 和 InnoDB 有什么区别？","slug":"myisam-和-innodb-有什么区别","link":"#myisam-和-innodb-有什么区别","children":[]},{"level":3,"title":"MyISAM 和 InnoDB 如何选择？","slug":"myisam-和-innodb-如何选择","link":"#myisam-和-innodb-如何选择","children":[]}]},{"level":2,"title":"MYSQL索引","slug":"mysql索引","link":"#mysql索引","children":[]},{"level":2,"title":"MYSQL查询缓存","slug":"mysql查询缓存","link":"#mysql查询缓存","children":[]},{"level":2,"title":"MYSQL日志","slug":"mysql日志","link":"#mysql日志","children":[]},{"level":2,"title":"MYSQL事务","slug":"mysql事务","link":"#mysql事务","children":[{"level":3,"title":"何为数据库事务？","slug":"何为数据库事务","link":"#何为数据库事务","children":[]},{"level":3,"title":"并发事务带来了哪些问题?","slug":"并发事务带来了哪些问题","link":"#并发事务带来了哪些问题","children":[]},{"level":3,"title":"不可重复读和幻读有什么区别？","slug":"不可重复读和幻读有什么区别","link":"#不可重复读和幻读有什么区别","children":[]},{"level":3,"title":"并发事务的控制方式有哪些？","slug":"并发事务的控制方式有哪些","link":"#并发事务的控制方式有哪些","children":[]},{"level":3,"title":"SQL标准定义了哪些事务隔离级别？","slug":"sql标准定义了哪些事务隔离级别","link":"#sql标准定义了哪些事务隔离级别","children":[]},{"level":3,"title":"MySQL 的隔离级别是基于锁实现的吗？","slug":"mysql-的隔离级别是基于锁实现的吗","link":"#mysql-的隔离级别是基于锁实现的吗","children":[]},{"level":3,"title":"MySQL 的默认隔离级别是什么?","slug":"mysql-的默认隔离级别是什么","link":"#mysql-的默认隔离级别是什么","children":[]}]},{"level":2,"title":"MYSQL锁","slug":"mysql锁","link":"#mysql锁","children":[]},{"level":2,"title":"MYSQL性能优化","slug":"mysql性能优化","link":"#mysql性能优化","children":[{"level":3,"title":"能用 MySQL 直接存储文件（比如图片）吗？","slug":"能用-mysql-直接存储文件-比如图片-吗","link":"#能用-mysql-直接存储文件-比如图片-吗","children":[]},{"level":3,"title":"MySQL 如何存储 IP 地址？","slug":"mysql-如何存储-ip-地址","link":"#mysql-如何存储-ip-地址","children":[]},{"level":3,"title":"有哪些常见的 SQL 优化手段？","slug":"有哪些常见的-sql-优化手段","link":"#有哪些常见的-sql-优化手段","children":[]},{"level":3,"title":"如何分析 SQL 的性能？","slug":"如何分析-sql-的性能","link":"#如何分析-sql-的性能","children":[]},{"level":3,"title":"读写分离和分库分表了解吗？","slug":"读写分离和分库分表了解吗","link":"#读写分离和分库分表了解吗","children":[]},{"level":3,"title":"深度分页如何优化？","slug":"深度分页如何优化","link":"#深度分页如何优化","children":[]},{"level":3,"title":"数据冷热分离如何做？","slug":"数据冷热分离如何做","link":"#数据冷热分离如何做","children":[]},{"level":3,"title":"MySQL 性能怎么优化？","slug":"mysql-性能怎么优化","link":"#mysql-性能怎么优化","children":[]}]}],"git":{"createdTime":1741663561000,"updatedTime":1742721462000,"contributors":[{"name":"Jaeger Eren","email":"erenjaegerking@qq.com","commits":7}]},"readingTime":{"minutes":12.49,"words":3748},"filePathRelative":"notes/database/a_mysql/mysql-javaguide.md","localizedDate":"2025年3月11日","excerpt":"<h2>MySQL基础</h2>\\n<h3>什么是关系型数据库？</h3>\\n<p>就是一种建立在关系型模型（表示存储数据之间的联系 一对一、一对多、多对多）上面的数据库。</p>\\n<h3>什么是SQL?</h3>\\n<p>结构化查询语言，专门用来与数据库打交道的</p>\\n<h3>什么是MySQL?</h3>\\n<p>它是开源免费的关系型数据库，主要用于持久化存储我们系统中的一些数据比如用户信息。</p>\\n<h3>MySQL有什么优点？</h3>\\n<p>免费开源 成熟稳定，功能完善 支持事务 多种引擎 文档丰富 社区活跃 支持分表分库、读写分离、高可用</p>\\n<h2>MySQL字段类型</h2>\\n<p>三大类：</p>","autoDesc":true}`);export{d as comp,o as data};
