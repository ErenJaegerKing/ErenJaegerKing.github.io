import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,e as a,o as i}from"./app-tK5k8aWv.js";const r={};function o(l,e){return i(),n("div",null,e[0]||(e[0]=[a('<hr><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>设计模式-行为型模式-中介者模式</p></div><hr><h3 id="动机" tabindex="-1"><a class="header-anchor" href="#动机"><span>动机</span></a></h3><p>一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如在下左图中，有六个同事类对象，假如对象1发生变化，那么将会有4个对象受到影响。如果对象2发生变化，那么将会有5个对象受到影响。也就是说，同事类之间直接关联的设计是不好的。</p><p>如果引入中介者模式，那么同事类之间的关系将变为星型结构，从下右图中可以看到，任何一个类的变动，只会影响的类本身，以及中介者，这样就减小了系统的耦合。一个好的设计，必定不会把所有的对象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为。</p><figure><img src="https://drawingbed-686.pages.dev/myblog/202411070935455.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义</span></a></h3><p>又叫<strong>调停模式</strong>，定义一个<strong>中介角色</strong>来<strong>封装一系列对象之间的交互</strong>，使原有对象之间的<strong>耦合松散</strong>，且可以<strong>独立地改变它们之间的交互</strong>。</p><h3 id="uml" tabindex="-1"><a class="header-anchor" href="#uml"><span>UML</span></a></h3><figure><img src="https://drawingbed-686.pages.dev/myblog/202411070936586.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="结构" tabindex="-1"><a class="header-anchor" href="#结构"><span>结构</span></a></h3><p>中介者模式包含以下主要角色：</p><ul><li><strong>抽象中介者（Mediator）角色</strong>：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li><li><strong>具体中介者（ConcreteMediator）角色</strong>：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</li><li><strong>抽象同事类（Colleague）角色</strong>：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</li><li><strong>具体同事类（Concrete Colleague）角色</strong>：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</li></ul><h3 id="案例实现" tabindex="-1"><a class="header-anchor" href="#案例实现"><span>案例实现</span></a></h3><p>【例】租房</p><p>现在租房基本都是通过房屋中介，房主将房屋托管给房屋中介，而租房者从房屋中介获取房屋信息。房屋中介充当租房者与房屋所有者之间的中介者。</p><figure><img src="https://drawingbed-686.pages.dev/myblog/202411070936194.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点"><span><strong>优缺点</strong></span></a></h3><p><strong>优点：</strong></p><ul><li><p><strong>松散耦合</strong></p><p>中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。</p></li><li><p><strong>集中控制交互</strong></p><p>多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。</p></li><li><p><strong>一对多关联转变为一对一的关联</strong></p><p>没有使用中介者模式的时候，同事对象之间的关系通常是一对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对一，这会让对象的关系更容易理解和实现。</p></li></ul><p><strong>缺点：</strong></p><ul><li><p>复杂而庞大</p><p>当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</p></li></ul><h3 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景"><span>适用场景</span></a></h3><ul><li>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。</li><li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li></ul>',25)]))}const g=t(r,[["render",o],["__file","g_mediator.html.vue"]]),d=JSON.parse('{"path":"/notes/designPattern/d_behavioral/g_mediator.html","title":"中介者模式","lang":"zh-CN","frontmatter":{"icon":"","description":"相关信息 设计模式-行为型模式-中介者模式 动机 一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如在下左图中，有六个同事类对象，假如对象1发生变化，那么将会有4个对象受到影响。如果对象2发生变化，那么将会有5个对象受到影响。也就是说，同事类之...","title":"中介者模式","date":"2024-11-07T00:00:00.000Z","category":["设计模式"],"tag":["行为型模式","中介者模式"],"order":7,"head":[["meta",{"property":"og:url","content":"https://he9.xin/notes/designPattern/d_behavioral/g_mediator.html"}],["meta",{"property":"og:site_name","content":"春风不语即随本心"}],["meta",{"property":"og:title","content":"中介者模式"}],["meta",{"property":"og:description","content":"相关信息 设计模式-行为型模式-中介者模式 动机 一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如在下左图中，有六个同事类对象，假如对象1发生变化，那么将会有4个对象受到影响。如果对象2发生变化，那么将会有5个对象受到影响。也就是说，同事类之..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://drawingbed-686.pages.dev/myblog/202411070935455.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-07T01:37:23.000Z"}],["meta",{"property":"article:author","content":"ErenJaegerKing"}],["meta",{"property":"article:tag","content":"行为型模式"}],["meta",{"property":"article:tag","content":"中介者模式"}],["meta",{"property":"article:published_time","content":"2024-11-07T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-07T01:37:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"中介者模式\\",\\"image\\":[\\"https://drawingbed-686.pages.dev/myblog/202411070935455.png\\",\\"https://drawingbed-686.pages.dev/myblog/202411070936586.png\\",\\"https://drawingbed-686.pages.dev/myblog/202411070936194.png\\"],\\"datePublished\\":\\"2024-11-07T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-07T01:37:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ErenJaegerKing\\",\\"url\\":\\"https://he9.xin\\",\\"email\\":\\"erenjaegerking@qq.com\\"}]}"]]},"headers":[{"level":3,"title":"动机","slug":"动机","link":"#动机","children":[]},{"level":3,"title":"定义","slug":"定义","link":"#定义","children":[]},{"level":3,"title":"UML","slug":"uml","link":"#uml","children":[]},{"level":3,"title":"结构","slug":"结构","link":"#结构","children":[]},{"level":3,"title":"案例实现","slug":"案例实现","link":"#案例实现","children":[]},{"level":3,"title":"优缺点","slug":"优缺点","link":"#优缺点","children":[]},{"level":3,"title":"适用场景","slug":"适用场景","link":"#适用场景","children":[]}],"git":{"createdTime":1730806731000,"updatedTime":1730943443000,"contributors":[{"name":"LiYaoYu","email":"ErenJaegerKing@qq.com","commits":2}]},"readingTime":{"minutes":3.45,"words":1034},"filePathRelative":"notes/designPattern/d_behavioral/g_mediator.md","localizedDate":"2024年11月7日","excerpt":"<hr>\\n<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">相关信息</p>\\n<p>设计模式-行为型模式-中介者模式</p>\\n</div>\\n<hr>\\n<h3>动机</h3>\\n<p>一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如在下左图中，有六个同事类对象，假如对象1发生变化，那么将会有4个对象受到影响。如果对象2发生变化，那么将会有5个对象受到影响。也就是说，同事类之间直接关联的设计是不好的。</p>","autoDesc":true}');export{g as comp,d as data};
