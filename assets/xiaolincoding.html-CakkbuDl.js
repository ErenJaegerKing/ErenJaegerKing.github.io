import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,f as s,o as n}from"./app-iEaeLszT.js";const l={};function p(t,e){return n(),i("div",null,e[0]||(e[0]=[s(`<div class="hint-container info"><p class="hint-container-title">相关信息</p><p>我的MySQL深入学习路径，以下内容是我自学的笔记，我是搬运工，此篇是学习小林coding博客的笔记。</p></div><h1 id="小林coding" tabindex="-1"><a class="header-anchor" href="#小林coding"><span><a href="https://xiaolincoding.com/mysql/" target="_blank" rel="noopener noreferrer">小林coding</a></span></a></h1><h2 id="基础篇" tabindex="-1"><a class="header-anchor" href="#基础篇"><span>基础篇</span></a></h2><h3 id="mysql-执行一条-select-查询语句-在-mysql-中期间发生了什么" tabindex="-1"><a class="header-anchor" href="#mysql-执行一条-select-查询语句-在-mysql-中期间发生了什么"><span>MySQL 执行一条 select 查询语句，在 MySQL 中期间发生了什么？</span></a></h3><p>连接器：建立连接，管理连接，校验用户身份</p><p>查询缓存：8.0已删除</p><p>解析SQL：解析器对SQL查询语法进行词法分析、语法分析，然后构建语法树，方便后续模块读取表明、字段、语句类型</p><p>执行SQL:有三个阶段</p><ul><li>预处理阶段:检查表或字段是否存在；将select* 中的*符号扩展为表上的所有列</li><li>优化阶段：选择查询成本最小的执行计划</li><li>执行阶段：根据执行计划执行SQL查询语句，从存储引擎读取记录，返回给客户端</li></ul><h4 id="mysql-执行流程是怎样的" tabindex="-1"><a class="header-anchor" href="#mysql-执行流程是怎样的"><span>MySQL 执行流程是怎样的？</span></a></h4><p>mysql的内部架构分为几层？</p><p>server层负责干嘛？</p><p>存储引擎负责干嘛？</p><h4 id="第一步-连接器" tabindex="-1"><a class="header-anchor" href="#第一步-连接器"><span>第一步：连接器</span></a></h4><p>先连接MySQL，然后才能执行SQL语句</p><p>连接的过程需要进行三次挥手，因为MySQL是基于TCP协议进行传输的</p><blockquote><p>如何查看MySQL服务被多少个客户端连接了？</p></blockquote><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">show</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> processlist</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><blockquote><p>空闲连接会一直占用吗？</p></blockquote><p>不会，MySQL定义了空闲连接的最大空闲时长，由wait_timeout参数控制，默认值是8个小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">show</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> variables</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> like</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;wait_timeout&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们可以手动断开空闲连接</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">kill</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> connection</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> +id</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><blockquote><p>MySQL的连接数有限制吗？</p></blockquote><p>MySQL的最大连接数由max_connections控制，比如mysql的服务默认是151个，超过这个值，系统就会拒绝接下来的连接请求，并报错提示&quot;Too many connections&quot;</p><p>MySQL的连接和HTTP一样，有短连接和长连接的概念</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 短连接</span></span>
<span class="line"><span>连接mysql服务（TCP三次挥手）</span></span>
<span class="line"><span>执行sql</span></span>
<span class="line"><span>断开mysql服务（TCP四次挥手）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 长连接</span></span>
<span class="line"><span>连接mysql服务（TCP三次挥手）</span></span>
<span class="line"><span>执行sql</span></span>
<span class="line"><span>执行sql</span></span>
<span class="line"><span>执行sql</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>断开mysql服务（TCP四次挥手）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用长连接的好处就是可以减少建立连接和断开连接的过程</p><p>但是长连接会导致占用内存增多，会发生MySQL服务异常重启的现象</p><blockquote><p>怎么解决长连接占用内存的问题？</p></blockquote><p>定期断开长连接</p><p>客户端主动重置连接，MySQL5.7实现了mysql_reset_connection()函数的接口，当执行一个很大的操作后，可以在代码里面调用这个函数来重置连接</p><p>总结：连接器的工作,与客户端进行TCP三次握手建立连接，校验客户端的用户名和密码，如果对了，就会读取该用户的权限，然后再后面的权限逻辑判断都会基于此时读取到的权限</p><h4 id="第二步-查询缓存" tabindex="-1"><a class="header-anchor" href="#第二步-查询缓存"><span>第二步：查询缓存</span></a></h4><p>很鸡肋的功能，在MySQL8.0开始就不会走查询缓存这个阶段了，也就是server层的查询缓存被移除了</p><h4 id="第三步-解析sql" tabindex="-1"><a class="header-anchor" href="#第三步-解析sql"><span>第三步：解析SQL</span></a></h4><p>在正式执行SQL查询语句之前，MySQL会先对SQL语句做解析，这个工作由解析器来完成</p><p>第一件事情：词法分析</p><p>分析后分为 关键字 和 非关键字</p><p>第二件事情：语法分析</p><p>语法解析器会根据语法规则，判断你输入的SQL语句是否满足MySQL语法，如果没问题就会构建出SQL语法树（方便后面获取SQL类型、表名、字段名、where条件）</p><h4 id="第四步-执行sql" tabindex="-1"><a class="header-anchor" href="#第四步-执行sql"><span>第四步：执行SQL</span></a></h4><p>正式执行SQL语句，进入三个阶段</p><p>1.prepare 预处理阶段</p><ul><li>检查SQL查询语句中的表或字段是否存在</li><li>将select * 中 * 符号，扩展为表上的所有列</li></ul><p>2.optimize 优化阶段</p><p>优化器主要负责将SQL查询语句的执行方案确定下来，比如表里面有多个索引，优化器会基于查询成本的考虑，来决定选择使用哪个索引</p><p>explain + 语句命令可以知道选择器选择了哪个索引</p><p>3.execute 执行阶段</p><p>执行器会与存储引擎交互，以记录为单位</p><p>read_first_record</p><h2 id="索引篇" tabindex="-1"><a class="header-anchor" href="#索引篇"><span>索引篇</span></a></h2><h3 id="索引常见面试题" tabindex="-1"><a class="header-anchor" href="#索引常见面试题"><span>索引常见面试题</span></a></h3><h4 id="什么是索引" tabindex="-1"><a class="header-anchor" href="#什么是索引"><span>什么是索引？</span></a></h4><p>索引是数据的目录</p><p>存储引擎，就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现</p><h4 id="索引的分类" tabindex="-1"><a class="header-anchor" href="#索引的分类"><span>索引的分类</span></a></h4><h5 id="按数据结构分类" tabindex="-1"><a class="header-anchor" href="#按数据结构分类"><span>按数据结构分类</span></a></h5><p>常见的索引B+Tree、HASH索引、Full-Text索引</p><p>InnoDB会在不同的创景下面选择不同的列作为聚簇索引：会有三种情况</p><p>其他索引都属于辅助索引，也被称为二级索引或非聚簇索引。创建的主键索引和二级索引默认使用的是B+Tree索引</p><p>B+Tree索引在存储数据中的具体实现是怎么样的？</p><p>存储在B+Tree索引时是长什么样子的？</p><p>B+Tree是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。</p><p>B+树存储千万级的数据只需要3-4层高度就可以满足，这意味这从千万级的表查询目标数据最多需要3-4此磁盘I/O，所以B+Tree相比于B树和二叉树来说，最大的优势在于查询效率很高，因为即便在数据量大的情况，查询一个数据的磁盘I/O依然维持在3-4次。</p><p>回表：查两个B+Tree才能查到数据</p><p>这种在二级索引的B+Tree就能查询到结果的过程就叫做覆盖索引，也就是只需要查一个B+Tree就能找到数据</p><blockquote><p>为什么MySQL InnoDB选择B+Tree作为索引的数据结构</p></blockquote><p><a href="https://mp.weixin.qq.com/s/w1ZFOug8-Sa7ThtMnlaUtQ" target="_blank" rel="noopener noreferrer">小林coding关于为什么选择做出的回答</a></p><p>1.B+Tree vs B Tree 2.B+Tree vs 二叉树 3.B+Tree vs Hash</p><h5 id="按物理存储分类" tabindex="-1"><a class="header-anchor" href="#按物理存储分类"><span>按物理存储分类</span></a></h5><p>索引分为 聚簇索引（主键索引）、二级索引（辅助索引）</p><p>就算数据存放在哪里的，</p><h5 id="按字段特性分类" tabindex="-1"><a class="header-anchor" href="#按字段特性分类"><span>按字段特性分类</span></a></h5><ol><li>主键索引</li></ol><p>最多只有一个索引，索引列的值不允许有空值</p><ol start="2"><li>唯一索引</li></ol><p>索引列的值必须唯一，但是允许有空值</p><ol start="3"><li><p>普通索引</p></li><li><p>前缀索引</p></li></ol><p>指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为char、varchar、binart、varbinary的列上</p><p>使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</p><h5 id="按字段个数分类" tabindex="-1"><a class="header-anchor" href="#按字段个数分类"><span>按字段个数分类</span></a></h5><p>单列索引、联合索引</p><p>联合索引：通过将多个字段组合成一个索引，该索引就被称为联合索引</p><p>使用联合索引时，存在最左匹配原则，如果不遵守最左匹配原则，联合索引会失效</p><p>就是（a，b，c）联合索引，是先按a排序，所以b和c是全局无序的，局部相对有序</p><p>利用索引的前提是索引里的key是有序的</p><p>联合索引范围查询</p><h4 id="什么时候需要-不需要创建索引" tabindex="-1"><a class="header-anchor" href="#什么时候需要-不需要创建索引"><span>什么时候需要/不需要创建索引？</span></a></h4><p>索引最大的好处是提高查询速度，但是索引有缺点：3个 物理空间、创建和维护、降低表的增删改效率</p><p>什么时候适合索引？2个 唯一 、WHERE GROUP BY/ORDER BY</p><p>什么时候不需要创建索引？4个 WHERE GROUP BY/ORDER BY 、 重复字段、 数据少、 频繁进行更新</p><h4 id="有什么优化索引的方法" tabindex="-1"><a class="header-anchor" href="#有什么优化索引的方法"><span>有什么优化索引的方法？</span></a></h4><p>4种常见的优化方法</p><ol><li>前缀索引优化 减小索引字段大小 局限性</li><li>覆盖索引优化 避免回标 减少了大量I/O操作</li><li>主键索引最好是自增的 好处是什么 什么情况下会出现页分裂</li><li>索引最好设置为NOT NULL 会导致优化器做索引选择的时候更加难count会省略值为NULL的行 会占用至少1字节空间存储NULL值列表</li><li>防止索引失效 <a href="https://mp.weixin.qq.com/s/lEx6iRRP3MbwJ82Xwp675w" target="_blank" rel="noopener noreferrer">小林coding更详细的了解索引失效</a> 执行效率从低到高的顺序为:?</li></ol><p><a href="https://xiaolincoding.com/mysql/index/index_interview.html#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener noreferrer">小林coding关于该索引原理的总结</a></p><h3 id="从数据页的角度看b-树" tabindex="-1"><a class="header-anchor" href="#从数据页的角度看b-树"><span>从数据页的角度看B+树</span></a></h3><p>B+树的节点里存放的是什么呢？查询数据的过程又是怎么样的？</p><h4 id="innodb是如何存储数据的" tabindex="-1"><a class="header-anchor" href="#innodb是如何存储数据的"><span>InnoDB是如何存储数据的？</span></a></h4><p>InnoDB的数据是按数据页为单位来读写的，数据I/O操作的最小单位是页，InnoDB数据页的默认大小是16KB</p><h4 id="b-树是如何进行查询的" tabindex="-1"><a class="header-anchor" href="#b-树是如何进行查询的"><span>B+树是如何进行查询的？</span></a></h4><p>InnoDB采用了B+树作为索引</p>`,102)]))}const d=a(l,[["render",p],["__file","xiaolincoding.html.vue"]]),o=JSON.parse('{"path":"/database/mysql/xiaolincoding.html","title":"观小林coding的读后感","lang":"zh-CN","frontmatter":{"icon":"","description":"相关信息 我的MySQL深入学习路径，以下内容是我自学的笔记，我是搬运工，此篇是学习小林coding博客的笔记。 小林coding 基础篇 MySQL 执行一条 select 查询语句，在 MySQL 中期间发生了什么？ 连接器：建立连接，管理连接，校验用户身份 查询缓存：8.0已删除 解析SQL：解析器对SQL查询语法进行词法分析、语法分析，然后构建...","title":"观小林coding的读后感","date":"2024-09-23T00:00:00.000Z","category":["数据库"],"tag":["MySQL"],"head":[["meta",{"property":"og:url","content":"https://ErenJaegerKing.github.io/database/mysql/xiaolincoding.html"}],["meta",{"property":"og:site_name","content":"ErenJaeger"}],["meta",{"property":"og:title","content":"观小林coding的读后感"}],["meta",{"property":"og:description","content":"相关信息 我的MySQL深入学习路径，以下内容是我自学的笔记，我是搬运工，此篇是学习小林coding博客的笔记。 小林coding 基础篇 MySQL 执行一条 select 查询语句，在 MySQL 中期间发生了什么？ 连接器：建立连接，管理连接，校验用户身份 查询缓存：8.0已删除 解析SQL：解析器对SQL查询语法进行词法分析、语法分析，然后构建..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-23T13:52:38.000Z"}],["meta",{"property":"article:author","content":"ErenJaegerKing"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:published_time","content":"2024-09-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-23T13:52:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"观小林coding的读后感\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-09-23T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-23T13:52:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ErenJaegerKing\\",\\"url\\":\\"https://ErenJaegerKing.github.io\\",\\"email\\":\\"1252505184@qq.com\\"}]}"]]},"headers":[{"level":2,"title":"基础篇","slug":"基础篇","link":"#基础篇","children":[{"level":3,"title":"MySQL 执行一条 select 查询语句，在 MySQL 中期间发生了什么？","slug":"mysql-执行一条-select-查询语句-在-mysql-中期间发生了什么","link":"#mysql-执行一条-select-查询语句-在-mysql-中期间发生了什么","children":[]}]},{"level":2,"title":"索引篇","slug":"索引篇","link":"#索引篇","children":[{"level":3,"title":"索引常见面试题","slug":"索引常见面试题","link":"#索引常见面试题","children":[]},{"level":3,"title":"从数据页的角度看B+树","slug":"从数据页的角度看b-树","link":"#从数据页的角度看b-树","children":[]}]}],"git":{"createdTime":1727099558000,"updatedTime":1727099558000,"contributors":[{"name":"LiYaoYu","email":"1252505184@qq.com","commits":1}]},"readingTime":{"minutes":7.84,"words":2352},"filePathRelative":"database/mysql/xiaolincoding.md","localizedDate":"2024年9月23日","excerpt":"<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">相关信息</p>\\n<p>我的MySQL深入学习路径，以下内容是我自学的笔记，我是搬运工，此篇是学习小林coding博客的笔记。</p>\\n</div>\\n<h1><a class=\\"header-anchor\\" href=\\"#小林coding\\"><span></span></a><a href=\\"https://xiaolincoding.com/mysql/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">小林coding</a></h1>","autoDesc":true}');export{d as comp,o as data};
