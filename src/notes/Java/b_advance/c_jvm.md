---
icon: ""
description: ""
title: "JVM相关"
date: 2024-10-27
category:
  - JVM
tag:
  - JVM相关
order: 1
---

## JVM基础

### 初识jvm

- 运行java字节码文件

- 功能

	- 解释和运行

	- 内存管理

	- 即时编写（just-in-time 简称jit）

- 常见的jvm

	- jvm虚拟机规范

### jvm的组成

- 类加载器classloader

- 运行时数据区域（jvm管理的内存）

- 执行引擎（即时编译器、解释器、垃圾回收器）

- 本地接口

### 字节码文件详解

- 以正确的姿势打开文件

	- jclasslib

- 详解组成

	- 基础信息

		- magic魔数

			- 校验文件的类型

		- 主副版本号

			- 主版本号-44=jdk版本

		- 访问标识

		- 类、父类、接口索引

	- 常量池

		- 符号引用

	- 字段

	- 方法

		- 操作数栈

		- 局部变量表

		- 字节码指令

			- iconst

			- istore

			- iload

			- iadd

			- return

			- iinc by

	- 属性

- 玩转字节码常用工具

	- javap -v 命令

		- jdk自带反编译工具，适合在服务器上查看字节码文件内容

	- jclasslib idea插件

	- 阿里arthas

		- 监控面板

			- dump

				- 已加载类的字节码文件到特定目录

		- 查看字节码信息

			- jad

				- 反编译已加载类的源码

		- 方法监控

		- 类的热部署

		- 内存监控

		- 垃圾回收监控

		- 应用热点定位

### 类加载器

- 类的生命周期

	- 生命周期概述

		- 加载

		- 连接

			- 验证

			- 准备

			- 解析

		- 初始化

		- 使用

		- 卸载

	- 加载阶段

		- 第一步、以不同渠道以二进制获取字节码信息

		- 第二步、jvm将字节码信息保存到内存的方法区（虚拟概念）

		- 第三步、生成InstanceKlass对象，保存类的所有信息，里面还包含实现特定功能比如多态的信息村

		- 第四步、jvm会在堆中生成一份与方法区中数据类似的java.lang.Class对象          在java代码中去获取类的信息以及存储静态字段的数据（jdk1.8之后）

		- 对于开发者只需要访问堆中的class对象而不需要访问方法区中的所有信息            控制开发者访问数据的范围

		- 查看内存中的对象

			- jdk自带的hsdb工具

				- java -cp

				- 如何获取进程号

					- jps

	- 连接阶段

		- 验证

			- 验证内容是否满足jvm规范

				- 1.文件格式验证，主副版本的检测

				- 2.元信息验证

				- 3.验证程序执行指令的语义

				- 4.符号引用验证

		- 准备

			- 给静态变量赋初始值

				- 在堆区中

		- 解析

			- 将常量池中的符号引用替换成指向内存的直接引用

	- 初始化阶段

		- 执行静态代码块中的代码，为静态变量赋值

		- -XX:+TraceClassLoading

			- 可以打印出加载并初始化的类

		- 执行字节码文件中clinit部分的字节码指令

			- putstatic

			- getstatic

			- ldc

			- invokvirtual

- 类加载器

	- 类加载器的分类

		- java代码

			- 扩展类加载类extension（通用非核心）

				- 加载/jre/lib/ext下的类文件

				- 加载用户jar包  使用参数进行扩展 -Djava.ext.dirs=jar包目录;自己的jar包目录 进行扩展

			- 应用程序类加载器appliaction（项目中的类和接口）

				- 加载classpath下的类文件

		- jvm底层源码 C++

			- 启动类加载器bootstrap（核心jar包）

				- 加载/jre/lib下的类文件，rt.jar，tools.jar，resources.jar

				- 加载用户jar包  使用参数进行扩展 -Xbootclasspath/a:jar包目录/jar包名 进行扩展

		- arthas使用classloader命令查看所有类加载器

			- classloader -l 会打印所有类加载器的hash码

		- arthas使用classloader -c hash查看类加载器的加载路径

	- 双亲委派机制

		- 有什么作用？

			- 1、保证类加载的安全性

				- 避免恶意代码替换jdk中的核心类库

			- 2、重复加载

				- 避免同一个类重复加载

		- 指的就是

			- 先自底向上查找是否加载过

			- 再由顶向下进行加载

		- arthas使用classloader -t可以查看类加载器的父子关系

	- 打破双亲委派机制

		- 自定义类加载器

			- 重写loadClass方法，将双亲委派机制的代码去除

			- Tomcat通过此实现应用之间类隔离

			- arthas中使用sc -d类名的方法查看具体的情况

		- 线程上下文类加载器

			- jdbc

				- spi jdk内置的服务提供发现机制

		- osgi框架的类加载器

			- 允许同级之间委派进行类的加载

			- arthas不停机热部署

				- jad --source-only 类全限定名 > 目录/文件名.java

					- jad命令反编译成源码保存起来

				- mc -c类加载器的hashcode 目录/文件名.java -d 输出目录

					- mc用来编译修改过的代码

				- retransform class 文件所在的目录/xxx.class

					- retransform命令加载新的字节码

				- sc -d 类全限定名  查询到类加载器对应的hash码

	- jdk9之后的类加载器

		- 启动类加载器    用java编写    BootClassLoader Java

		- 扩展类加载器 变成了平台类加载器 platform classloader

			- 为了与老版本的设计方案兼容

	- 应用场景

		- spi机制

		- 类的热部署

		- tomcat类的隔离

		- 什么是类的双亲委派机制

		- 打破类的双亲委派机制

		- 自定义类加载器

		- 使用arthas不停机解决线上故障

### 运行时数据区

- 线程不共享

	- 程序计数器program counter register

		- 也叫pc寄存器

			- 每个线程会通过程序计数器记录当前要执行的字节码指令的地址

		- 不会发生内存溢出，因为每个线程只存储一个固定长度的内存地址

	- java虚拟机栈   java virtual machine stack

		- 采用栈的数据结构来管理方法调用中的基本数据，先进后出，每一个方法的调用使用一个栈帧来保存

		- 生命周期是随线程的创建而创建的，随着线程的销毁而回收，每个线程都会包含一个自己的虚拟机栈

		- 栈帧的组成

			- 局部变量表

				- 在运行过程中存放所有的局部变量

					- 编号

						- Nr. 

					- 生效范围

						- 起始pc

						- 长度

					- 槽的起始编号

						- 序号

							- 槽是可以复用的

							- long和double占用两个槽

							- 实例方法的this对象，方法的参数，方法体中声明的局部变量

					- 名字

			- 操作数栈

				- 执行指令过程中用来存放临时数据一块区域

					- 编译期就可以确定操作数栈的最大深度

			- 帧数据

				- 包含动态链接、方法出口、异常表的引用

		- 栈内存溢出 StackOverflowError

		- jvm会创建一个默认大小的栈

		- 设置大小

			- -Xss栈大小

				- 字节（1024的倍数）、k、m、g

		- 注意事项

			- 1、类似的：-XX:ThreadStackSize=栈大小

			- 2、HotSpotJVM对栈大小的最大值和最小值有要求

			- 3、局部变量过多、操作数栈深度过大也会影响栈内存的大小

			- 一般情况下，工作中即便使用了递归进行操作，栈的深度最多也只能到几百，不会出现栈的溢出。所以此参数可以手动指定为-Xss256k节省内存

	- 本地方法栈

		- java虚拟机栈存储了java方法调用时的栈帧，而本地方法栈存储的是native本地方法的栈帧

		- java虚拟机栈和本地方法栈实现上使用了同一个栈空间

- 线程共享

	- 堆

		- 堆内存是空间最大的一块内存区域，创建出来的对象都在堆上

		- 内存溢出

			- 是指程序在使用某一块内存区域时，存放的数据需要占用的内存大小超过了虚拟机能提供的内存上线

		- 堆区溢出

			- outofmemory

		- used total max

		- 在arthas使用dashboard命令可以看到

			- dashborad -i 刷新频率（毫秒）

			- memory

		- max默认是系统内存的四分之一，total默认是系统内存的六十四分之一

		- 设置大小

			- -Xmx值

			- -Xms值

		- 注意事项

			- 建议将-Xmx和-Xms设置为相同的值

	- 方法区

		- 方法区是存放基础信息的位置

			- 类的元信息

				- 在类的加载阶段完成

			- 运行时常量池

			- 字符串常量池

		- 方法区存放在哪里？

			- jdk7及之前

				- 存放在堆区域中的永久代空间permgen spac

					- -XX:MaxPermSize=值

			- jdk8及之后

				- 存放在元空间

					- 元空间位于操作系统维护的直接内存中

						- -XX:MaxMetaspaceSize=值

		- arthas中查看方法区      使用memory

			- jdk7及之前

				- ps_perm_gen

			- jdk8及之后

				- metaspace

		- 字符串常量池

			- jdk7之前

				- 运行时常量池包含字符串常量池   hotspot虚拟机堆方法区的实现为永久代

			- jdk7

				- 字符串常量被从方法区拿到了堆中，运行时常量池剩下的东西还在永久代

			- jdk8之后

				- hotspot移除了永久代用元空间代替，字符串常量还在堆中

			- String.intern()方法是可以手动将字符串放入字符串常量池

				- jdk6及之前

					- 会把第一次遇到的字符串实例复制到永久代的字符串常量池中，返回的也就是永久代里面的这个字符串实例的引用

				- jdk7及之后

					- 由于字符串常量池在堆上，所以intern（）方法会把第一次遇到的字符串的引用放入字符串常量池

			- 例外：静态变量存储在哪里？

				- jdk6及之前

					- 静态变量是存放在方法区的，也就是永久代

				- jdk7及之后 

					- 静态变量是存放在堆中的Class对象中，脱离了永久代

- 直接内存

	- 不属于java运行时的内存区域

	- 元空间属于直接内存中的一块区域

### 执行引擎

- 方法区的回收

	- 不再使用的类

		- 要同时满足三个条件

			- 已全部回收

			- 类加载器以被回收

			- 没有被引用

	- 手动触发回收

		- system.gc（）

			- 由jvm自行判断

- 堆回收

	- 引用计数法和可达性分析法

		- 如何判断堆上的对象没有被引用？

		- 引用计数法

			- 缺点

				- 引用和取消引用会对系统性能有影响

				- 存在循环引用问题

		- 可达性分析法

			- 垃圾回收的根对象（GC Root）

				- 线程Thread对象

				- 系统类加载器加载的java.lang.Class对象

				- 监控器对象，用来保存同步锁synchronized关键字持有的对象

				- 本地方法调用是使用的全局对象

			- 普通对象

		- 查看垃圾回收日志

			- -verbose:gc参数

	- 五种对象引用

		- 软引用

			- Caffeine

				- Redis多级缓存

			- SoftReference

				- 常用于缓存

		- 弱引用

			- 用于ThreadLocal

			- WeakReference

			- 弱引用包含的对象在垃圾回收时，不管内存够不够都会直接被回收

		- 虚引用

		- 终结器引用

	- 垃圾回收算法

		- 核心思想

			- 1、找到内存中存活的对象

			- 2、释放不再存活对象的内存

		- 评价标准

			- STW

			- 1、吞吐量 

				- 执行用户代码的时间 / （执行用户代码时间 + GC时间）

			- 2、最大暂停时间

			- 3、堆使用效率

		- 常见的垃圾回收算法

			- 标记-清楚算法

				- mark sweep gc

					- 核心思想

						- 标记

							- GC Root

						- 清除

					- 优点

						- 实现简单

					- 缺点

						- 1、碎片化

						- 2、分配速度慢

			- 复制算法

				- copying gc

					- 核心思想

						- From和To空间

							- 放于From

						- gc阶段

							- 存活的从From复制到To

						- 交换名字

					- 优点

						- 吞吐量高

						- 不会发生碎片化

					- 缺点

						- 内存使用效率低

			- 标记-整理算法

				- mark compact gc

					- 核心思想

						- 标记

							- GC Root

						- 整理

							- 移动到堆的一端

								- 清除

					- 优点

						- 内存使用效率高

						- 不会发生碎片化

					- 缺点

						- 整理阶段的效率不高

			- 分代 gc

				- generational gc

					- 核心思想

						- 将整个内存区域划分成年轻代和老年代

							- 年轻代

								- Eden区伊甸园

								- S0 Survivor 幸存区

								- S1

								- 年轻代-Xmn

								- Eden与S0的比例-XX:SurvivorRatio

							- 老年代

						- Young GC/Minor GC

							- 回收eden和from

							- 没回收的放入to

							- 记录年龄

						- s0与s1互换from和to

						- 年龄达到阈值就会晋升老年代     默认15

						- 老年代空间不足

							- 先minor gc

							- 不足就full gc

						- out of memory

					- arthas查看分代之后的内存情况

						- jdk中添加

							- -XX:+UserSerialGC

						- 使用memory命令查看内存

	- 垃圾回收器

		- 组合关系 上下一一对应

			- 年轻代

				- Serial垃圾回收器

					- 单线程串行

					- 复制算法

					- 优点

						- 单CPU处理器下吞吐量非常出色

					- 缺点

						- 多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待

					- 适用场景

						- java编写的客户端程序或者硬件有限的场景

				- ParNew垃圾回收器

					- 多线程

					- 复制算法

					- -XX:+UseParNewGC

					- 优点

						- 多CPU处理器下停顿时间较短

					- 缺点

						- 吞吐量和停顿时间不如G1，所以在JDK9之后比建议使用

					- 适用场景

						- JDK8及之前的版本中，与CMS老年代垃圾回收器搭配使用

				- Parallel Scavenge垃圾回收器

					- 多线程并行

						- 关注系统的吞吐量

							- 自动调整堆内存大小

					- 复制算法

					- 优点

						- 吞吐量高，而且手动可控

						- 为了提高吞吐量，虚拟机会动态调整堆的参数

					- 缺点

						- 不能保证单次的停顿时间

					- 适用场景

						- 后台任务，不需要与用户交互，并且容易产生大量的对象，比如：大数据的处理，文件的导出

			- 老年代

				- SerialOld垃圾回收器

					- 单线程串行

					- 标记-整理算法

					- -XX:+UseSerialGC

					- 优点

						- 单CPU处理器下吞吐量非常出色

					- 缺点

						- 多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待

					- 适用场景

						- 与Serial垃圾回收器配合使用，或者在CMS特殊情况下使用

				- CMS垃圾回收器

					- 关注系统的暂停时间

						- 允许用户线程和垃圾回收线程可以同时进行

					- 标记-清除算法

					- -XX:+UseConcMarkSweepGC

					- 优点

						- 系统由于垃圾回收出现的停顿时间较短，用户体验好

					- 缺点

						- 1、内存碎片问题

						- 2、退化问题

						- 3、浮动垃圾问题

					- 适用场景

						- 大型互联网系统中用户请求数据量大、频率高的场景，比如订单接口、商品接口等

				- Parallel Old垃圾回收器

					- 多线程并行

					- 标记-整理算法

					- 优点

						- 并发收集，在多核CPU下效率较高

					- 缺点

						- 暂停时间会比较长

					- 适用场景

						- 与paraller Scavenge配套使用

					- -XX:UseParallelGC

					- -XX:UseParallelOldGC

						- 会使用Parallel Scavenge垃圾回收器 和 Parallel Old垃圾回收器 组合使用

		- G1垃圾回收器

			- jdk9之后默认是garbage first

			- 优点

				- 1、支持巨大的堆空间回收，并有较高的吞吐量

				- 2、支持多CPU并行垃圾回收

				- 3、允许用户设置最大暂停时间

			- 内存结构

				- 堆划分成多个大小相同的区域 称为区Region，区域不要求是连续的

					- Eden

					- Survivor

					- Old

			- 两种方式

				- 1、年轻代回收（Young GC）

				- 2、混合回收（Mixed GC）

			- 回收年代和算法

				- 年轻代和老年代

				- 复制算法

			- 优点

				- 对比较大的堆如超过6g的堆时，延迟可控

				- 不会产生内存碎片

				- 并发标记的SATB算法效率高

			- 缺点

				- jdk8之前还不够成熟

			- 适用场景

				- jdk8最新版本、jdk9之后建议默认适用

		- 如何选择

			- jdk8及之前

				- 关注暂停时间

					- parnew + cms

				- 关注吞吐量

					- parallel scavenge + parallel old

				- jdk8-较大堆并且关注暂停时间

			- jdk9之后

				- g1默认

## 参考资料

[黑马程序员JVM视频](https://www.bilibili.com/video/BV1r94y1b7eS?spm_id_from=333.788.videopod.episodes&vd_source=834d9d69a86c55d6acbaf9e5dbe37bb2)

[JVM讲义](https://lisxpq12rl7.feishu.cn/wiki/ZaKnwhhhmiDu9ekUnRNcv2iNnof)