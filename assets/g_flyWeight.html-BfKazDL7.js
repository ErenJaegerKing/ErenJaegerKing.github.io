import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,e as i,o as a}from"./app-DDugn0gO.js";const l={};function r(o,e){return a(),n("div",null,e[0]||(e[0]=[i('<hr><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>设计模式-结构性模式-享元模式</p></div><hr><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义</span></a></h3><p>运用共享技术来有效地支持大量细粒度对象的复用。<strong>它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销</strong>，从而提高系统资源的利用率。</p><h3 id="结构" tabindex="-1"><a class="header-anchor" href="#结构"><span>结构</span></a></h3><p>享元（Flyweight ）模式中存在以下两种状态：</p><ol><li>内部状态，即不会随着环境的改变而改变的可共享部分。</li><li>外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。</li></ol><p>享元模式的主要有以下角色：</p><ul><li><strong>抽象享元角色（Flyweight）</strong>：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li><li><strong>具体享元（Concrete Flyweight）角色</strong> ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</li><li><strong>非享元（Unsharable Flyweight)角色</strong> ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</li><li><strong>享元工厂（Flyweight Factory）角色</strong> ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li></ul><h3 id="uml" tabindex="-1"><a class="header-anchor" href="#uml"><span>UML</span></a></h3><figure><img src="https://drawingbed-686.pages.dev/myblog/202411101633402.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="案例实现" tabindex="-1"><a class="header-anchor" href="#案例实现"><span>案例实现</span></a></h3><p>【例】俄罗斯方块</p><p>如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。</p><figure><img src="https://drawingbed-686.pages.dev/myblog/202411101633516.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点"><span>优缺点</span></a></h3><p><strong>优点</strong></p><ul><li>极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能</li><li>享元模式中的外部状态相对独立，且不影响内部状态</li></ul><p><strong>缺点：</strong></p><ul><li>为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂</li></ul><h3 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景"><span><strong>适用场景</strong></span></a></h3><ul><li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li><li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li><li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li></ul><h3 id="jdk源码解析" tabindex="-1"><a class="header-anchor" href="#jdk源码解析"><span><strong>JDK源码解析</strong></span></a></h3><p>Integer类使用了享元模式</p><p>直接给Integer类型的变量赋值基本数据类型数据的操作底层使用的是 <code>valueOf()</code> ，所以只需要看该方法即可 可以看到 <code>Integer</code> 默认先创建并缓存 <code>-128 ~ 127</code> 之间数的 <code>Integer</code> 对象，当调用 <code>valueOf</code> 时如果参数在 <code>-128 ~ 127</code> 之间则计算下标并从缓存中返回，否则创建一个新的 <code>Integer</code> 对象。</p>',26)]))}const g=t(l,[["render",r],["__file","g_flyWeight.html.vue"]]),c=JSON.parse('{"path":"/notes/designPattern/c_structural/g_flyWeight.html","title":"享元模式","lang":"zh-CN","frontmatter":{"icon":"","description":"相关信息 设计模式-结构性模式-享元模式 定义 运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。 结构 享元（Flyweight ）模式中存在以下两种状态： 内部状态，即不会随着环境的改变而改变的可共享部分。 外部状态，指随环境改变而改变的不可以共享...","title":"享元模式","date":"2024-11-12T00:00:00.000Z","category":["设计模式"],"tag":["结构性模式","享元模式"],"order":7,"head":[["meta",{"property":"og:url","content":"https://he9.xin/notes/designPattern/c_structural/g_flyWeight.html"}],["meta",{"property":"og:site_name","content":"春风不语即随本心"}],["meta",{"property":"og:title","content":"享元模式"}],["meta",{"property":"og:description","content":"相关信息 设计模式-结构性模式-享元模式 定义 运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。 结构 享元（Flyweight ）模式中存在以下两种状态： 内部状态，即不会随着环境的改变而改变的可共享部分。 外部状态，指随环境改变而改变的不可以共享..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://drawingbed-686.pages.dev/myblog/202411101633402.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-10T08:37:39.000Z"}],["meta",{"property":"article:author","content":"ErenJaegerKing"}],["meta",{"property":"article:tag","content":"结构性模式"}],["meta",{"property":"article:tag","content":"享元模式"}],["meta",{"property":"article:published_time","content":"2024-11-12T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-10T08:37:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"享元模式\\",\\"image\\":[\\"https://drawingbed-686.pages.dev/myblog/202411101633402.png\\",\\"https://drawingbed-686.pages.dev/myblog/202411101633516.png\\"],\\"datePublished\\":\\"2024-11-12T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-10T08:37:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ErenJaegerKing\\",\\"url\\":\\"https://he9.xin\\",\\"email\\":\\"erenjaegerking@qq.com\\"}]}"]]},"headers":[{"level":3,"title":"定义","slug":"定义","link":"#定义","children":[]},{"level":3,"title":"结构","slug":"结构","link":"#结构","children":[]},{"level":3,"title":"UML","slug":"uml","link":"#uml","children":[]},{"level":3,"title":"案例实现","slug":"案例实现","link":"#案例实现","children":[]},{"level":3,"title":"优缺点","slug":"优缺点","link":"#优缺点","children":[]},{"level":3,"title":"适用场景","slug":"适用场景","link":"#适用场景","children":[]},{"level":3,"title":"JDK源码解析","slug":"jdk源码解析","link":"#jdk源码解析","children":[]}],"git":{"createdTime":1730726433000,"updatedTime":1731227859000,"contributors":[{"name":"LiYaoYu","email":"ErenJaegerKing@qq.com","commits":3}]},"readingTime":{"minutes":3.16,"words":949},"filePathRelative":"notes/designPattern/c_structural/g_flyWeight.md","localizedDate":"2024年11月12日","excerpt":"<hr>\\n<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">相关信息</p>\\n<p>设计模式-结构性模式-享元模式</p>\\n</div>\\n<hr>\\n<h3>定义</h3>\\n<p>运用共享技术来有效地支持大量细粒度对象的复用。<strong>它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销</strong>，从而提高系统资源的利用率。</p>\\n<h3>结构</h3>\\n<p>享元（Flyweight ）模式中存在以下两种状态：</p>\\n<ol>\\n<li>内部状态，即不会随着环境的改变而改变的可共享部分。</li>\\n<li>外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。</li>\\n</ol>","autoDesc":true}');export{g as comp,c as data};
