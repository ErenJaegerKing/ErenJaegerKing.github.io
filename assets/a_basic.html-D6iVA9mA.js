import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as p,e as u,o as a}from"./app-BDYMNmXe.js";const e={};function r(t,l){return a(),p("div",null,l[0]||(l[0]=[u('<hr><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>JVM基础 学习黑马课程的笔记<a href="https://www.bilibili.com/video/BV1r94y1b7eS?spm_id_from=333.788.videopod.episodes&amp;vd_source=834d9d69a86c55d6acbaf9e5dbe37bb2" target="_blank" rel="noopener noreferrer">转载：黑马程序员JVM视频</a></p></div><hr><h1 id="jvm基础" tabindex="-1"><a class="header-anchor" href="#jvm基础"><span>JVM基础</span></a></h1><h3 id="初识jvm" tabindex="-1"><a class="header-anchor" href="#初识jvm"><span>初识jvm</span></a></h3><ul><li><p>运行java字节码文件</p></li><li><p>功能</p><ul><li><p>解释和运行</p></li><li><p>内存管理</p></li><li><p>即时编写（just-in-time 简称jit）</p></li></ul></li><li><p>常见的jvm</p><ul><li>jvm虚拟机规范</li></ul></li></ul><h3 id="jvm的组成" tabindex="-1"><a class="header-anchor" href="#jvm的组成"><span>jvm的组成</span></a></h3><ul><li><p>类加载器classloader</p></li><li><p>运行时数据区域（jvm管理的内存）</p></li><li><p>执行引擎（即时编译器、解释器、垃圾回收器）</p></li><li><p>本地接口</p></li></ul><h3 id="字节码文件详解" tabindex="-1"><a class="header-anchor" href="#字节码文件详解"><span>字节码文件详解</span></a></h3><ul><li><p>以正确的姿势打开文件</p><ul><li>jclasslib</li></ul></li><li><p>详解组成</p><ul><li><p>基础信息</p><ul><li><p>magic魔数</p><ul><li>校验文件的类型</li></ul></li><li><p>主副版本号</p><ul><li>主版本号-44=jdk版本</li></ul></li><li><p>访问标识</p></li><li><p>类、父类、接口索引</p></li></ul></li><li><p>常量池</p><ul><li>符号引用</li></ul></li><li><p>字段</p></li><li><p>方法</p><ul><li><p>操作数栈</p></li><li><p>局部变量表</p></li><li><p>字节码指令</p><ul><li><p>iconst</p></li><li><p>istore</p></li><li><p>iload</p></li><li><p>iadd</p></li><li><p>return</p></li><li><p>iinc by</p></li></ul></li></ul></li><li><p>属性</p></li></ul></li><li><p>玩转字节码常用工具</p><ul><li><p>javap -v 命令</p><ul><li>jdk自带反编译工具，适合在服务器上查看字节码文件内容</li></ul></li><li><p>jclasslib idea插件</p></li><li><p>阿里arthas</p><ul><li><p>监控面板</p><ul><li><p>dump</p><ul><li>已加载类的字节码文件到特定目录</li></ul></li></ul></li><li><p>查看字节码信息</p><ul><li><p>jad</p><ul><li>反编译已加载类的源码</li></ul></li></ul></li><li><p>方法监控</p></li><li><p>类的热部署</p></li><li><p>内存监控</p></li><li><p>垃圾回收监控</p></li><li><p>应用热点定位</p></li></ul></li></ul></li></ul><h3 id="类加载器" tabindex="-1"><a class="header-anchor" href="#类加载器"><span>类加载器</span></a></h3><ul><li><p>类的生命周期</p><ul><li><p>生命周期概述</p><ul><li><p>加载</p></li><li><p>连接</p><ul><li><p>验证</p></li><li><p>准备</p></li><li><p>解析</p></li></ul></li><li><p>初始化</p></li><li><p>使用</p></li><li><p>卸载</p></li></ul></li><li><p>加载阶段</p><ul><li><p>第一步、以不同渠道以二进制获取字节码信息</p></li><li><p>第二步、jvm将字节码信息保存到内存的方法区（虚拟概念）</p></li><li><p>第三步、生成InstanceKlass对象，保存类的所有信息，里面还包含实现特定功能比如多态的信息村</p></li><li><p>第四步、jvm会在堆中生成一份与方法区中数据类似的java.lang.Class对象 在java代码中去获取类的信息以及存储静态字段的数据（jdk1.8之后）</p></li><li><p>对于开发者只需要访问堆中的class对象而不需要访问方法区中的所有信息 控制开发者访问数据的范围</p></li><li><p>查看内存中的对象</p><ul><li><p>jdk自带的hsdb工具</p><ul><li><p>java -cp</p></li><li><p>如何获取进程号</p><ul><li>jps</li></ul></li></ul></li></ul></li></ul></li><li><p>连接阶段</p><ul><li><p>验证</p><ul><li><p>验证内容是否满足jvm规范</p><ul><li><p>1.文件格式验证，主副版本的检测</p></li><li><p>2.元信息验证</p></li><li><p>3.验证程序执行指令的语义</p></li><li><p>4.符号引用验证</p></li></ul></li></ul></li><li><p>准备</p><ul><li><p>给静态变量赋初始值</p><ul><li>在堆区中</li></ul></li></ul></li><li><p>解析</p><ul><li>将常量池中的符号引用替换成指向内存的直接引用</li></ul></li></ul></li><li><p>初始化阶段</p><ul><li><p>执行静态代码块中的代码，为静态变量赋值</p></li><li><p>-XX:+TraceClassLoading</p><ul><li>可以打印出加载并初始化的类</li></ul></li><li><p>执行字节码文件中clinit部分的字节码指令</p><ul><li><p>putstatic</p></li><li><p>getstatic</p></li><li><p>ldc</p></li><li><p>invokvirtual</p></li></ul></li></ul></li></ul></li><li><p>类加载器</p><ul><li><p>类加载器的分类</p><ul><li><p>java代码</p><ul><li><p>扩展类加载类extension（通用非核心）</p><ul><li><p>加载/jre/lib/ext下的类文件</p></li><li><p>加载用户jar包 使用参数进行扩展 -Djava.ext.dirs=jar包目录;自己的jar包目录 进行扩展</p></li></ul></li><li><p>应用程序类加载器appliaction（项目中的类和接口）</p><ul><li>加载classpath下的类文件</li></ul></li></ul></li><li><p>jvm底层源码 C++</p><ul><li><p>启动类加载器bootstrap（核心jar包）</p><ul><li><p>加载/jre/lib下的类文件，rt.jar，tools.jar，resources.jar</p></li><li><p>加载用户jar包 使用参数进行扩展 -Xbootclasspath/a:jar包目录/jar包名 进行扩展</p></li></ul></li></ul></li><li><p>arthas使用classloader命令查看所有类加载器</p><ul><li>classloader -l 会打印所有类加载器的hash码</li></ul></li><li><p>arthas使用classloader -c hash查看类加载器的加载路径</p></li></ul></li><li><p>双亲委派机制</p><ul><li><p>有什么作用？</p><ul><li><p>1、保证类加载的安全性</p><ul><li>避免恶意代码替换jdk中的核心类库</li></ul></li><li><p>2、重复加载</p><ul><li>避免同一个类重复加载</li></ul></li></ul></li><li><p>指的就是</p><ul><li><p>先自底向上查找是否加载过</p></li><li><p>再由顶向下进行加载</p></li></ul></li><li><p>arthas使用classloader -t可以查看类加载器的父子关系</p></li></ul></li><li><p>打破双亲委派机制</p><ul><li><p>自定义类加载器</p><ul><li><p>重写loadClass方法，将双亲委派机制的代码去除</p></li><li><p>Tomcat通过此实现应用之间类隔离</p></li><li><p>arthas中使用sc -d类名的方法查看具体的情况</p></li></ul></li><li><p>线程上下文类加载器</p><ul><li><p>jdbc</p><ul><li>spi jdk内置的服务提供发现机制</li></ul></li></ul></li><li><p>osgi框架的类加载器</p><ul><li><p>允许同级之间委派进行类的加载</p></li><li><p>arthas不停机热部署</p><ul><li><p>jad --source-only 类全限定名 &gt; 目录/文件名.java</p><ul><li>jad命令反编译成源码保存起来</li></ul></li><li><p>mc -c类加载器的hashcode 目录/文件名.java -d 输出目录</p><ul><li>mc用来编译修改过的代码</li></ul></li><li><p>retransform class 文件所在的目录/xxx.class</p><ul><li>retransform命令加载新的字节码</li></ul></li><li><p>sc -d 类全限定名 查询到类加载器对应的hash码</p></li></ul></li></ul></li></ul></li><li><p>jdk9之后的类加载器</p><ul><li><p>启动类加载器 用java编写 BootClassLoader Java</p></li><li><p>扩展类加载器 变成了平台类加载器 platform classloader</p><ul><li>为了与老版本的设计方案兼容</li></ul></li></ul></li><li><p>应用场景</p><ul><li><p>spi机制</p></li><li><p>类的热部署</p></li><li><p>tomcat类的隔离</p></li><li><p>什么是类的双亲委派机制</p></li><li><p>打破类的双亲委派机制</p></li><li><p>自定义类加载器</p></li><li><p>使用arthas不停机解决线上故障</p></li></ul></li></ul></li></ul><h3 id="运行时数据区" tabindex="-1"><a class="header-anchor" href="#运行时数据区"><span>运行时数据区</span></a></h3><ul><li><p>线程不共享</p><ul><li><p>程序计数器program counter register</p><ul><li><p>也叫pc寄存器</p><ul><li>每个线程会通过程序计数器记录当前要执行的字节码指令的地址</li></ul></li><li><p>不会发生内存溢出，因为每个线程只存储一个固定长度的内存地址</p></li></ul></li><li><p>java虚拟机栈 java virtual machine stack</p><ul><li><p>采用栈的数据结构来管理方法调用中的基本数据，先进后出，每一个方法的调用使用一个栈帧来保存</p></li><li><p>生命周期是随线程的创建而创建的，随着线程的销毁而回收，每个线程都会包含一个自己的虚拟机栈</p></li><li><p>栈帧的组成</p><ul><li><p>局部变量表</p><ul><li><p>在运行过程中存放所有的局部变量</p><ul><li><p>编号</p><ul><li>Nr.</li></ul></li><li><p>生效范围</p><ul><li><p>起始pc</p></li><li><p>长度</p></li></ul></li><li><p>槽的起始编号</p><ul><li><p>序号</p><ul><li><p>槽是可以复用的</p></li><li><p>long和double占用两个槽</p></li><li><p>实例方法的this对象，方法的参数，方法体中声明的局部变量</p></li></ul></li></ul></li><li><p>名字</p></li></ul></li></ul></li><li><p>操作数栈</p><ul><li><p>执行指令过程中用来存放临时数据一块区域</p><ul><li>编译期就可以确定操作数栈的最大深度</li></ul></li></ul></li><li><p>帧数据</p><ul><li>包含动态链接、方法出口、异常表的引用</li></ul></li></ul></li><li><p>栈内存溢出 StackOverflowError</p></li><li><p>jvm会创建一个默认大小的栈</p></li><li><p>设置大小</p><ul><li><p>-Xss栈大小</p><ul><li>字节（1024的倍数）、k、m、g</li></ul></li></ul></li><li><p>注意事项</p><ul><li><p>1、类似的：-XX:ThreadStackSize=栈大小</p></li><li><p>2、HotSpotJVM对栈大小的最大值和最小值有要求</p></li><li><p>3、局部变量过多、操作数栈深度过大也会影响栈内存的大小</p></li><li><p>一般情况下，工作中即便使用了递归进行操作，栈的深度最多也只能到几百，不会出现栈的溢出。所以此参数可以手动指定为-Xss256k节省内存</p></li></ul></li></ul></li><li><p>本地方法栈</p><ul><li><p>java虚拟机栈存储了java方法调用时的栈帧，而本地方法栈存储的是native本地方法的栈帧</p></li><li><p>java虚拟机栈和本地方法栈实现上使用了同一个栈空间</p></li></ul></li></ul></li><li><p>线程共享</p><ul><li><p>堆</p><ul><li><p>堆内存是空间最大的一块内存区域，创建出来的对象都在堆上</p></li><li><p>内存溢出</p><ul><li>是指程序在使用某一块内存区域时，存放的数据需要占用的内存大小超过了虚拟机能提供的内存上线</li></ul></li><li><p>堆区溢出</p><ul><li>outofmemory</li></ul></li><li><p>used total max</p></li><li><p>在arthas使用dashboard命令可以看到</p><ul><li><p>dashborad -i 刷新频率（毫秒）</p></li><li><p>memory</p></li></ul></li><li><p>max默认是系统内存的四分之一，total默认是系统内存的六十四分之一</p></li><li><p>设置大小</p><ul><li><p>-Xmx值</p></li><li><p>-Xms值</p></li></ul></li><li><p>注意事项</p><ul><li>建议将-Xmx和-Xms设置为相同的值</li></ul></li></ul></li><li><p>方法区</p><ul><li><p>方法区是存放基础信息的位置</p><ul><li><p>类的元信息</p><ul><li>在类的加载阶段完成</li></ul></li><li><p>运行时常量池</p></li><li><p>字符串常量池</p></li></ul></li><li><p>方法区存放在哪里？</p><ul><li><p>jdk7及之前</p><ul><li><p>存放在堆区域中的永久代空间permgen spac</p><ul><li>-XX:MaxPermSize=值</li></ul></li></ul></li><li><p>jdk8及之后</p><ul><li><p>存放在元空间</p><ul><li><p>元空间位于操作系统维护的直接内存中</p><ul><li>-XX:MaxMetaspaceSize=值</li></ul></li></ul></li></ul></li></ul></li><li><p>arthas中查看方法区 使用memory</p><ul><li><p>jdk7及之前</p><ul><li>ps_perm_gen</li></ul></li><li><p>jdk8及之后</p><ul><li>metaspace</li></ul></li></ul></li><li><p>字符串常量池</p><ul><li><p>jdk7之前</p><ul><li>运行时常量池包含字符串常量池 hotspot虚拟机堆方法区的实现为永久代</li></ul></li><li><p>jdk7</p><ul><li>字符串常量被从方法区拿到了堆中，运行时常量池剩下的东西还在永久代</li></ul></li><li><p>jdk8之后</p><ul><li>hotspot移除了永久代用元空间代替，字符串常量还在堆中</li></ul></li><li><p>String.intern()方法是可以手动将字符串放入字符串常量池</p><ul><li><p>jdk6及之前</p><ul><li>会把第一次遇到的字符串实例复制到永久代的字符串常量池中，返回的也就是永久代里面的这个字符串实例的引用</li></ul></li><li><p>jdk7及之后</p><ul><li>由于字符串常量池在堆上，所以intern（）方法会把第一次遇到的字符串的引用放入字符串常量池</li></ul></li></ul></li><li><p>例外：静态变量存储在哪里？</p><ul><li><p>jdk6及之前</p><ul><li>静态变量是存放在方法区的，也就是永久代</li></ul></li><li><p>jdk7及之后</p><ul><li>静态变量是存放在堆中的Class对象中，脱离了永久代</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>直接内存</p><ul><li><p>不属于java运行时的内存区域</p></li><li><p>元空间属于直接内存中的一块区域</p></li></ul></li></ul><h3 id="执行引擎" tabindex="-1"><a class="header-anchor" href="#执行引擎"><span>执行引擎</span></a></h3><ul><li><p>方法区的回收</p><ul><li><p>不再使用的类</p><ul><li><p>要同时满足三个条件</p><ul><li><p>已全部回收</p></li><li><p>类加载器以被回收</p></li><li><p>没有被引用</p></li></ul></li></ul></li><li><p>手动触发回收</p><ul><li><p>system.gc（）</p><ul><li>由jvm自行判断</li></ul></li></ul></li></ul></li><li><p>堆回收</p><ul><li><p>引用计数法和可达性分析法</p><ul><li><p>如何判断堆上的对象没有被引用？</p></li><li><p>引用计数法</p><ul><li><p>缺点</p><ul><li><p>引用和取消引用会对系统性能有影响</p></li><li><p>存在循环引用问题</p></li></ul></li></ul></li><li><p>可达性分析法</p><ul><li><p>垃圾回收的根对象（GC Root）</p><ul><li><p>线程Thread对象</p></li><li><p>系统类加载器加载的java.lang.Class对象</p></li><li><p>监控器对象，用来保存同步锁synchronized关键字持有的对象</p></li><li><p>本地方法调用是使用的全局对象</p></li></ul></li><li><p>普通对象</p></li></ul></li><li><p>查看垃圾回收日志</p><ul><li>-verbose:gc参数</li></ul></li></ul></li><li><p>五种对象引用</p><ul><li><p>软引用</p><ul><li><p>Caffeine</p><ul><li>Redis多级缓存</li></ul></li><li><p>SoftReference</p><ul><li>常用于缓存</li></ul></li></ul></li><li><p>弱引用</p><ul><li><p>用于ThreadLocal</p></li><li><p>WeakReference</p></li><li><p>弱引用包含的对象在垃圾回收时，不管内存够不够都会直接被回收</p></li></ul></li><li><p>虚引用</p></li><li><p>终结器引用</p></li></ul></li><li><p>垃圾回收算法</p><ul><li><p>核心思想</p><ul><li><p>1、找到内存中存活的对象</p></li><li><p>2、释放不再存活对象的内存</p></li></ul></li><li><p>评价标准</p><ul><li><p>STW</p></li><li><p>1、吞吐量</p><ul><li>执行用户代码的时间 / （执行用户代码时间 + GC时间）</li></ul></li><li><p>2、最大暂停时间</p></li><li><p>3、堆使用效率</p></li></ul></li><li><p>常见的垃圾回收算法</p><ul><li><p>标记-清楚算法</p><ul><li><p>mark sweep gc</p><ul><li><p>核心思想</p><ul><li><p>标记</p><ul><li>GC Root</li></ul></li><li><p>清除</p></li></ul></li><li><p>优点</p><ul><li>实现简单</li></ul></li><li><p>缺点</p><ul><li><p>1、碎片化</p></li><li><p>2、分配速度慢</p></li></ul></li></ul></li></ul></li><li><p>复制算法</p><ul><li><p>copying gc</p><ul><li><p>核心思想</p><ul><li><p>From和To空间</p><ul><li>放于From</li></ul></li><li><p>gc阶段</p><ul><li>存活的从From复制到To</li></ul></li><li><p>交换名字</p></li></ul></li><li><p>优点</p><ul><li><p>吞吐量高</p></li><li><p>不会发生碎片化</p></li></ul></li><li><p>缺点</p><ul><li>内存使用效率低</li></ul></li></ul></li></ul></li><li><p>标记-整理算法</p><ul><li><p>mark compact gc</p><ul><li><p>核心思想</p><ul><li><p>标记</p><ul><li>GC Root</li></ul></li><li><p>整理</p><ul><li><p>移动到堆的一端</p><ul><li>清除</li></ul></li></ul></li></ul></li><li><p>优点</p><ul><li><p>内存使用效率高</p></li><li><p>不会发生碎片化</p></li></ul></li><li><p>缺点</p><ul><li>整理阶段的效率不高</li></ul></li></ul></li></ul></li><li><p>分代 gc</p><ul><li><p>generational gc</p><ul><li><p>核心思想</p><ul><li><p>将整个内存区域划分成年轻代和老年代</p><ul><li><p>年轻代</p><ul><li><p>Eden区伊甸园</p></li><li><p>S0 Survivor 幸存区</p></li><li><p>S1</p></li><li><p>年轻代-Xmn</p></li><li><p>Eden与S0的比例-XX:SurvivorRatio</p></li></ul></li><li><p>老年代</p></li></ul></li><li><p>Young GC/Minor GC</p><ul><li><p>回收eden和from</p></li><li><p>没回收的放入to</p></li><li><p>记录年龄</p></li></ul></li><li><p>s0与s1互换from和to</p></li><li><p>年龄达到阈值就会晋升老年代 默认15</p></li><li><p>老年代空间不足</p><ul><li><p>先minor gc</p></li><li><p>不足就full gc</p></li></ul></li><li><p>out of memory</p></li></ul></li><li><p>arthas查看分代之后的内存情况</p><ul><li><p>jdk中添加</p><ul><li>-XX:+UserSerialGC</li></ul></li><li><p>使用memory命令查看内存</p></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>垃圾回收器</p><ul><li><p>组合关系 上下一一对应</p><ul><li><p>年轻代</p><ul><li><p>Serial垃圾回收器</p><ul><li><p>单线程串行</p></li><li><p>复制算法</p></li><li><p>优点</p><ul><li>单CPU处理器下吞吐量非常出色</li></ul></li><li><p>缺点</p><ul><li>多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待</li></ul></li><li><p>适用场景</p><ul><li>java编写的客户端程序或者硬件有限的场景</li></ul></li></ul></li><li><p>ParNew垃圾回收器</p><ul><li><p>多线程</p></li><li><p>复制算法</p></li><li><p>-XX:+UseParNewGC</p></li><li><p>优点</p><ul><li>多CPU处理器下停顿时间较短</li></ul></li><li><p>缺点</p><ul><li>吞吐量和停顿时间不如G1，所以在JDK9之后比建议使用</li></ul></li><li><p>适用场景</p><ul><li>JDK8及之前的版本中，与CMS老年代垃圾回收器搭配使用</li></ul></li></ul></li><li><p>Parallel Scavenge垃圾回收器</p><ul><li><p>多线程并行</p><ul><li><p>关注系统的吞吐量</p><ul><li>自动调整堆内存大小</li></ul></li></ul></li><li><p>复制算法</p></li><li><p>优点</p><ul><li><p>吞吐量高，而且手动可控</p></li><li><p>为了提高吞吐量，虚拟机会动态调整堆的参数</p></li></ul></li><li><p>缺点</p><ul><li>不能保证单次的停顿时间</li></ul></li><li><p>适用场景</p><ul><li>后台任务，不需要与用户交互，并且容易产生大量的对象，比如：大数据的处理，文件的导出</li></ul></li></ul></li></ul></li><li><p>老年代</p><ul><li><p>SerialOld垃圾回收器</p><ul><li><p>单线程串行</p></li><li><p>标记-整理算法</p></li><li><p>-XX:+UseSerialGC</p></li><li><p>优点</p><ul><li>单CPU处理器下吞吐量非常出色</li></ul></li><li><p>缺点</p><ul><li>多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待</li></ul></li><li><p>适用场景</p><ul><li>与Serial垃圾回收器配合使用，或者在CMS特殊情况下使用</li></ul></li></ul></li><li><p>CMS垃圾回收器</p><ul><li><p>关注系统的暂停时间</p><ul><li>允许用户线程和垃圾回收线程可以同时进行</li></ul></li><li><p>标记-清除算法</p></li><li><p>-XX:+UseConcMarkSweepGC</p></li><li><p>优点</p><ul><li>系统由于垃圾回收出现的停顿时间较短，用户体验好</li></ul></li><li><p>缺点</p><ul><li><p>1、内存碎片问题</p></li><li><p>2、退化问题</p></li><li><p>3、浮动垃圾问题</p></li></ul></li><li><p>适用场景</p><ul><li>大型互联网系统中用户请求数据量大、频率高的场景，比如订单接口、商品接口等</li></ul></li></ul></li><li><p>Parallel Old垃圾回收器</p><ul><li><p>多线程并行</p></li><li><p>标记-整理算法</p></li><li><p>优点</p><ul><li>并发收集，在多核CPU下效率较高</li></ul></li><li><p>缺点</p><ul><li>暂停时间会比较长</li></ul></li><li><p>适用场景</p><ul><li>与paraller Scavenge配套使用</li></ul></li><li><p>-XX:UseParallelGC</p></li><li><p>-XX:UseParallelOldGC</p><ul><li>会使用Parallel Scavenge垃圾回收器 和 Parallel Old垃圾回收器 组合使用</li></ul></li></ul></li></ul></li></ul></li><li><p>G1垃圾回收器</p><ul><li><p>jdk9之后默认是garbage first</p></li><li><p>优点</p><ul><li><p>1、支持巨大的堆空间回收，并有较高的吞吐量</p></li><li><p>2、支持多CPU并行垃圾回收</p></li><li><p>3、允许用户设置最大暂停时间</p></li></ul></li><li><p>内存结构</p><ul><li><p>堆划分成多个大小相同的区域 称为区Region，区域不要求是连续的</p><ul><li><p>Eden</p></li><li><p>Survivor</p></li><li><p>Old</p></li></ul></li></ul></li><li><p>两种方式</p><ul><li><p>1、年轻代回收（Young GC）</p></li><li><p>2、混合回收（Mixed GC）</p></li></ul></li><li><p>回收年代和算法</p><ul><li><p>年轻代和老年代</p></li><li><p>复制算法</p></li></ul></li><li><p>优点</p><ul><li><p>对比较大的堆如超过6g的堆时，延迟可控</p></li><li><p>不会产生内存碎片</p></li><li><p>并发标记的SATB算法效率高</p></li></ul></li><li><p>缺点</p><ul><li>jdk8之前还不够成熟</li></ul></li><li><p>适用场景</p><ul><li>jdk8最新版本、jdk9之后建议默认适用</li></ul></li></ul></li><li><p>如何选择</p><ul><li><p>jdk8及之前</p><ul><li><p>关注暂停时间</p><ul><li>parnew + cms</li></ul></li><li><p>关注吞吐量</p><ul><li>parallel scavenge + parallel old</li></ul></li><li><p>jdk8-较大堆并且关注暂停时间</p></li></ul></li><li><p>jdk9之后</p><ul><li>g1默认</li></ul></li></ul></li></ul></li></ul></li></ul>',16)]))}const n=i(e,[["render",r],["__file","a_basic.html.vue"]]),c=JSON.parse('{"path":"/notes/Java/d_jvm/a_basic.html","title":"JVM基础","lang":"zh-CN","frontmatter":{"icon":"","description":"相关信息 JVM基础 学习黑马课程的笔记转载：黑马程序员JVM视频 JVM基础 初识jvm 运行java字节码文件 功能 解释和运行 内存管理 即时编写（just-in-time 简称jit） 常见的jvm jvm虚拟机规范 jvm的组成 类加载器classloader 运行时数据区域（jvm管理的内存） 执行引擎（即时编译器、解释器、垃圾回收器） 本...","title":"JVM基础","date":"2024-10-27T00:00:00.000Z","category":["JVM"],"tag":["JVM基础"],"order":1,"head":[["meta",{"property":"og:url","content":"https://ErenJaegerKing.github.io/notes/Java/d_jvm/a_basic.html"}],["meta",{"property":"og:site_name","content":"ErenJaeger"}],["meta",{"property":"og:title","content":"JVM基础"}],["meta",{"property":"og:description","content":"相关信息 JVM基础 学习黑马课程的笔记转载：黑马程序员JVM视频 JVM基础 初识jvm 运行java字节码文件 功能 解释和运行 内存管理 即时编写（just-in-time 简称jit） 常见的jvm jvm虚拟机规范 jvm的组成 类加载器classloader 运行时数据区域（jvm管理的内存） 执行引擎（即时编译器、解释器、垃圾回收器） 本..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-04T14:59:50.000Z"}],["meta",{"property":"article:author","content":"ErenJaegerKing"}],["meta",{"property":"article:tag","content":"JVM基础"}],["meta",{"property":"article:published_time","content":"2024-10-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-04T14:59:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM基础\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-10-27T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-04T14:59:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ErenJaegerKing\\",\\"url\\":\\"https://ErenJaegerKing.github.io\\",\\"email\\":\\"erenjaegerking@qq.com\\"}]}"]]},"headers":[{"level":3,"title":"初识jvm","slug":"初识jvm","link":"#初识jvm","children":[]},{"level":3,"title":"jvm的组成","slug":"jvm的组成","link":"#jvm的组成","children":[]},{"level":3,"title":"字节码文件详解","slug":"字节码文件详解","link":"#字节码文件详解","children":[]},{"level":3,"title":"类加载器","slug":"类加载器","link":"#类加载器","children":[]},{"level":3,"title":"运行时数据区","slug":"运行时数据区","link":"#运行时数据区","children":[]},{"level":3,"title":"执行引擎","slug":"执行引擎","link":"#执行引擎","children":[]}],"git":{"createdTime":1727102579000,"updatedTime":1730732390000,"contributors":[{"name":"LiYaoYu","email":"ErenJaegerKing@qq.com","commits":1}]},"readingTime":{"minutes":13.05,"words":3916},"filePathRelative":"notes/Java/d_jvm/a_basic.md","localizedDate":"2024年10月27日","excerpt":"<hr>\\n<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">相关信息</p>\\n<p>JVM基础 学习黑马课程的笔记<a href=\\"https://www.bilibili.com/video/BV1r94y1b7eS?spm_id_from=333.788.videopod.episodes&amp;vd_source=834d9d69a86c55d6acbaf9e5dbe37bb2\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">转载：黑马程序员JVM视频</a></p>\\n</div>","autoDesc":true}');export{n as comp,c as data};
